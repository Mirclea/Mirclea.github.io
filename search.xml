<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CS01</title>
      <link href="/2022/09/24/CG01/"/>
      <url>/2022/09/24/CG01/</url>
      
        <content type="html"><![CDATA[<h2 id="线性代数基础"><a href="#线性代数基础" class="headerlink" title="*线性代数基础"></a>*线性代数基础</h2><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><ul><li>用$\vec{a} 或者 \pmb{a}$表示向量，$\hat{a} = \frac{\vec{a}}{|\vec{a}|} $，表示单位向量<ul><li>向量的坐标形式，列向量$\vec{a} = \begin{pmatrix} x \ y \ z \end{pmatrix}$</li><li>$\pmb{a}^T = \begin{pmatrix} x &amp; y &amp; z \end{pmatrix} , 转置运算$</li></ul></li><li>向量的运算：<ul><li>$\vec{a} \cdot \vec{b} = |\vec{a}||\vec{b}|cos\theta，其中\theta为向量\vec{a},\vec{b}的夹角$</li><li>$\vec{a} \times  \vec{b} = -  \vec{b} \times \vec{a},|\vec{a} \times  \vec{b}| = |\vec{a}||\vec{b}|sin\theta$</li></ul></li></ul><blockquote><p>对于 $\vec{a} \times  \vec{b} $ 必然可以转换成矩阵和向量的乘积，相当对于向量的旋转即 $\pmb{a} \times \pmb{b} = C\pmb{b}$</p><p>对于$\pmb{a} = \begin{pmatrix} x_a \ y_a \ z_a  \end{pmatrix},\pmb{b} = \begin{pmatrix} x_b \ y_b \ z_b  \end{pmatrix} , \pmb{a} \times \pmb{b} = C\pmb{b} = \begin{pmatrix} 0 &amp; -z_a &amp; y_a \ z_a &amp; 0 &amp; -x_a\  -y_a &amp; x_a &amp; 0\end{pmatrix}\begin{pmatrix} x_b \ y_b \ z_b  \end{pmatrix} = \begin{pmatrix} y_az_b-y_bz_z \ z_ax_b-x_az_b \ x_ay_b-y_ax_b  \end{pmatrix}$</p></blockquote><ul><li>向量运算的应用：<ul><li>投影变换</li><li>向量相对位置的确定</li><li>点是否在图形内部的确定</li></ul></li></ul><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><ul><li>对于矩阵的定义不在给出（读者可以自行查询）</li><li>矩阵乘法：$M_{n\times m} * N_{m \times t} = A_{n \times t}$</li></ul><h2 id="★图像变换"><a href="#★图像变换" class="headerlink" title="★图像变换"></a>★图像变换</h2><p>主要的目的：3D World  $\rightarrow$ 2D Image</p><h3 id="2D的变换"><a href="#2D的变换" class="headerlink" title="2D的变换"></a>2D的变换</h3><h4 id="缩放反转"><a href="#缩放反转" class="headerlink" title="缩放反转"></a>缩放反转</h4><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/5.png" alt="缩放演示"></p><p>下面的公式便是代表了2D图像的缩放</p><script type="math/tex; mode=display">\left\{\begin{aligned} x' = S_xx\\   y' = S_yy\\\end{aligned}\right.</script><script type="math/tex; mode=display">\begin{pmatrix} x' \\ y' \end{pmatrix} = \begin{pmatrix} S_x & 0\\ 0 & S_y \end{pmatrix} \begin{pmatrix} x \\ y \end{pmatrix}</script><p>这个公式代表了对在x轴方式向上缩放$S_x$倍，对在y轴方式向上缩放$S_y$倍</p><blockquote><p>对于图像的反转，可以对$S_x = -1 或者 S_y = -1$操作方式与缩放完全一样</p></blockquote><h4 id="切变-shear"><a href="#切变-shear" class="headerlink" title="切变(shear)"></a>切变(shear)</h4><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220924102859076.png" alt="切变"></p><p>下面的公式代表了上方2D图像的切变</p><script type="math/tex; mode=display">\left\{\begin{aligned}x' = x + ay\\y' = y\end{aligned}\right.</script><script type="math/tex; mode=display">\begin{pmatrix}x'\\y'\end{pmatrix}=\begin{pmatrix}1 & a\\0 & 1\end{pmatrix}\begin{pmatrix}x\\y\end{pmatrix}</script><h4 id="旋转-Rotate"><a href="#旋转-Rotate" class="headerlink" title="旋转(Rotate)"></a>旋转(Rotate)</h4><blockquote><p>默认来说，都是关于原点(0,0)选择，不在原点旋转的可利用平移转化，并且默认为逆时针旋转</p></blockquote><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220924104631364.png" alt="旋转"></p><p><strong>旋转矩阵</strong>的结果，记住就可以了</p><script type="math/tex; mode=display">R_{\theta} = \begin{pmatrix}cos\theta & -sin\theta\\sin\theta & cos\theta\end{pmatrix}</script><h4 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h4><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220924105056731.png" alt="平移"></p><script type="math/tex; mode=display">\begin{equation}\begin{array}{l}x^{\prime}=x+t_x \\y^{\prime}=y+t_y\end{array}\end{equation}</script><p>但是对于平移出现了一个问题，无论如何变形，对于 上述的变形式子 无法变为$ \pmb{x’} = D\pmb{x}$的形式，这个问题会在下一节中展示</p><blockquote><p>对于$ \pmb{x’} = D\pmb{x}$形式的</p></blockquote><h3 id="齐次线性变换"><a href="#齐次线性变换" class="headerlink" title="齐次线性变换"></a>齐次线性变换</h3><p>为了更好的表示齐次线性表示所有的变换，为了不让平移变成一个特殊，我们在每个向量或者点添加一维元素如下表示：</p><ul><li>$ 2Dpoint = (x,y,1)^T $</li><li>$2D vector = (x,y,0)^T$</li></ul><p>这次可以利用以下公式对于<strong>线性变换</strong>表示平移：</p><script type="math/tex; mode=display">\left(\begin{array}{c}x^{\prime} \\y^{\prime} \\w^{\prime}\end{array}\right)=\left(\begin{array}{ccc}1 & 0 & t_x \\0 & 1 & t_y \\0 & 0 & 1\end{array}\right) \cdot\left(\begin{array}{l}x \\y \\1\end{array}\right)=\left(\begin{array}{c}x+t_x \\y+t_y \\1\end{array}\right)</script><p>对于前面说的缩放反转、切变、旋转都可以用扩展后的矩阵进行齐次变换只需要如下公式：</p><ul><li><p>缩放   $\mathbf{S}\left(s_x, s_y\right)=\left(\begin{array}{ccc}s_x &amp; 0 &amp; 0 \ 0 &amp; s_y &amp; 0 \ 0 &amp; 0 &amp; 1\end{array}\right)$</p></li><li><p>旋转 $\mathbf{R}(\alpha)=\left(\begin{array}{ccc}\cos \alpha &amp; -\sin \alpha &amp; 0 \ \sin \alpha &amp; \cos \alpha &amp; 0 \ 0 &amp; 0 &amp; 1\end{array}\right)$</p></li></ul><blockquote><p>注意：$\mathbf{R}(-\alpha)=\left(\begin{array}{ccc}\cos \alpha &amp; \sin \alpha &amp; 0 \ -\sin \alpha &amp; \cos \alpha &amp; 0 \ 0 &amp; 0 &amp; 1\end{array}\right) = \mathbf{R}(\alpha)^{-1} = \mathbf{R}(\alpha)^T$</p></blockquote><ul><li>平移 $\mathbf{T}\left(t_x, t_y\right)=\left(\begin{array}{ccc}1 &amp; 0 &amp; t_x \ 0 &amp; 1 &amp; t_y \ 0 &amp; 0 &amp; 1\end{array}\right)$</li></ul><blockquote><p>对于前两个，我们发现，仅仅用我们之前推导的$2\times2$的变换矩阵，替换这个$3\times3$的矩阵的左上方的$2\times2$的格子即可，对于平移我们只要在单位矩阵的第三列前两个元素添加平移的距离即可完成变换</p></blockquote><p>由于变换具有组合性，故对于一个变换都可以分解成多个基础齐次线性变换，所以对于一个变换矩阵M,都可以分解成上述的S、R、T的乘积，例如</p><script type="math/tex; mode=display">T_{(1,0)} \cdot R_{45}\left[\begin{array}{l}x \\ y \\ 1\end{array}\right]=\left[\begin{array}{lll}1 & 0 & 1 \\ 0 & 1 & 0 \\ 0 & 0 & 1\end{array}\right]\left[\begin{array}{ccc}\cos 45^{\circ} & -\sin 45^{\circ} & 0 \\ \sin 45^{\circ} & \cos 45^{\circ} & 0 \\ 0 & 0 & 1\end{array}\right]\left[\begin{array}{l}x \\ y \\ 1\end{array}\right]\\</script><blockquote><p> 代表先对图像逆时针旋转45°再平移(1,0)的距离</p></blockquote><p>此时我们可以知道$M = T_{(1,0)} \cdot R_{45},M代表整个过程的变换矩阵$</p><h4 id="非原点变换"><a href="#非原点变换" class="headerlink" title="非原点变换"></a>非原点变换</h4><p>一句话，平移至原点再变换。例如下图，</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220924121952208.png" alt="非原点变化的过程"></p><h3 id="3D的变换"><a href="#3D的变换" class="headerlink" title="3D的变换"></a>3D的变换</h3><p>类比于2D的变换，我们也可以类比2D齐次变换</p><ul><li>$ 3Dpoint = (x,y,z,1)^T $</li><li>$3D vector = (x,y,z,0)^T$</li></ul><p>对其线性变换如下公式：</p><script type="math/tex; mode=display">\left(\begin{array}{l}x^{\prime} \\y^{\prime} \\z^{\prime} \\1\end{array}\right)=\left(\begin{array}{lllc}a & b & c & t_x \\d & e & f & t_y \\g & h & i & t_z \\0 & 0 & 0 & 1\end{array}\right) \cdot\left(\begin{array}{l}x \\y \\z \\1\end{array}\right)</script><blockquote><p>对于这种扩展点的定义，我们也可以扩充至$\omega \neq 1，0$的情况，对于$(x,y,z,\omega),\omega \neq 0 代表真实点(x/\omega,y/\omega,z/\omega) $</p></blockquote><p>思考：对于应用上面的3D的齐次线性变换的变换矩阵，变换时是先平移还是先旋转（或者线性变化）呢 ？</p><font color="red"> *答：先进行线性变换，再平移*</font> <p>对于上面的相关的变换矩阵性质可以类比于2D变换的矩阵性质</p><h4 id="特殊的旋转矩阵"><a href="#特殊的旋转矩阵" class="headerlink" title="特殊的旋转矩阵"></a>特殊的旋转矩阵</h4><p>围绕x-、y-、z-轴旋转，如下矩阵：</p><script type="math/tex; mode=display">\begin{aligned}&\mathbf{R}_x(\alpha)=\left(\begin{array}{cccc}1 & 0 & 0 & 0 \\0 & \cos \alpha & -\sin \alpha & 0 \\0 & \sin \alpha & \cos \alpha & 0 \\0 & 0 & 0 & 1\end{array}\right) \\&\mathbf{R}_y(\alpha)=\left(\begin{array}{cccc}\cos \alpha & 0 & \sin \alpha & 0 \\0 & 1 & 0 & 0 \\-\sin \alpha & 0 & \cos \alpha & 0 \\0 & 0 & 0 & 1\end{array}\right) \\&\mathbf{R}_z(\alpha)=\left(\begin{array}{cccc}\cos \alpha & -\sin \alpha & 0 & 0 \\\sin \alpha & \cos \alpha & 0 & 0 \\0 & 0 & 1 & 0 \\0 & 0 & 0 & 1\end{array}\right)\end{aligned}</script><p>因此对于<strong>欧拉角</strong>我们可以这样转换为矩阵： $\mathbf{R}_{x y z}(\alpha, \beta, \gamma)=\mathbf{R}_x(\alpha) \mathbf{R}_y(\beta) \mathbf{R}_z(\gamma)$ 一般旋转</p><p>非欧拉角旋转矩阵求法</p><script type="math/tex; mode=display">\mathbf{R}(\mathbf{n}, \alpha)=\cos (\alpha) \mathbf{I}+(1-\cos (\alpha)) \mathbf{n} \mathbf{n}^T+\sin (\alpha) \underbrace{\left(\begin{array}{ccc}0 & -n_z & n_y \\n_z & 0 & -n_x \\-n_y & n_x & 0\end{array}\right)}_{\mathbf{N}}\\\mathbf{n}为旋转轴方向,\alpha为旋转角度</script><blockquote><p>默认旋转轴过原点</p></blockquote><h3 id="3D转换成2D"><a href="#3D转换成2D" class="headerlink" title="3D转换成2D"></a>3D转换成2D</h3><h4 id="view变换"><a href="#view变换" class="headerlink" title="view变换"></a>view变换</h4><ul><li>观测点位置（拍照位置）==== 默认（0，0，0）</li><li>观察方向（拍的方向）==== 默认  向-z的方向看</li><li>观察点旋转方向（相机旋转的方向）==== 默认 向上方向是y轴方向</li></ul><p>将一个一般观测点转化成上述默认方向</p><ul><li>先将位置平移到原点 </li></ul><script type="math/tex; mode=display">T_{\text {view }}=\left[\begin{array}{cccc}1 & 0 & 0 & -x_e \\ 0 & 1 & 0 & -y_e \\ 0 & 0 & 1 & -z_e \\ 0 & 0 & 0 & 1\end{array}\right]</script><ul><li>在旋转到默认方向</li></ul><script type="math/tex; mode=display">R_{\text {view }}=\left[\begin{array}{cccc}x_{\hat{g} \times \hat{t}} & y_{\hat{g} \times \hat{t}} & z_{\hat{g} \times \hat{t}} & 0 \\ x_t & y_t & z_t & 0 \\ x_{-g} & y_{-g} & z_{-g} & 0 \\ 0 & 0 & 0 & 1 \end{array}\right]</script><ul><li>变换矩阵$\mathbf{M} = R_{view} T_{view}$</li></ul><h4 id="Projection变换"><a href="#Projection变换" class="headerlink" title="Projection变换"></a>Projection变换</h4><p>3D转2D的关键步骤</p><h5 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h5><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220924160910708.png" alt="正交投影"></p><p>变换：直接去掉某一面的坐标元素量</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220924161115181.png" alt="规范的变换"></p><ul><li><p>我们定义一个长方体$[l,r]\times[b,t]\times[f,n]$</p></li><li><p>映射到坐标$[-1,1]^3$上，规范化，映射矩阵如下（先平移，再缩放）</p></li></ul><script type="math/tex; mode=display">M_{\text {ortho }}=\left[\begin{array}{cccc}\frac{2}{r-l} & 0 & 0 & 0 \\0 & \frac{2}{t-b} & 0 & 0 \\0 & 0 & \frac{2}{n-f} & 0 \\0 & 0 & 0 & 1\end{array}\right]\left[\begin{array}{cccc}1 & 0 & 0 & -\frac{r+l}{2} \\0 & 1 & 0 & -\frac{t+b}{2} \\0 & 0 & 1 & -\frac{n+f}{2} \\0 & 0 & 0 & 1\end{array}\right]</script><h5 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h5><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/tsty.jpg" alt="透视投影"></p><p>回顾：对于$(x,y,z,1)与(kx,ky,kz,k),k\ne0$表示为同一个点</p><p>透视投影完成的步骤：</p><ul><li>先收缩f处的画面(远近的间距不变、图像中心点不变)  $M^{(4\times4)}_{presp \rightarrow ortho}$</li><li><p>将收缩后的画面正交投影到n处 $M_{\text {ortho }}$ </p></li><li><p>透视变换矩阵 $M_{presp} = M_{ortho} \cdot M_{presp \rightarrow ortho}  $</p></li></ul><p>通过一定的推导我们可以求解到压缩变换矩阵 <a href="https://www.bilibili.com/video/BV1X7411F744/?p=4&amp;spm_id_from=pageDriver&amp;vd_source=57e5130c3375ea877ab660ca10500f21">推导过程</a></p><p>思考：对于远近平面挤压时，对于其z值挤压前后不变，那么除了f、n两处的面，其他的面挤压前后的z应该是怎样变换？（n~f之间的面） <a href="https://zhuanlan.zhihu.com/p/445801392">答案解析</a></p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220924163833203.png" alt="透视投影变化"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SMPL Note</title>
      <link href="/2022/09/24/SMPL%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/09/24/SMPL%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="SMPL学习笔记"><a href="#SMPL学习笔记" class="headerlink" title="SMPL学习笔记"></a>SMPL学习笔记</h1><blockquote><p>人体的表示：</p><ol><li><p>只有关节点</p></li><li><p>关节点和边 </p><p>（注意：1、2都叫人体姿态估计 pose estimation）</p></li><li><p>SMPL：包含高矮胖瘦，但不包含手势、脚踝、表情等的mesh表示。</p></li><li><p>SMPL-X: 包含手势、脚踝、表情等的mesh表示。</p></li></ol></blockquote><h2 id="SMPL-简介"><a href="#SMPL-简介" class="headerlink" title="SMPL 简介"></a>SMPL 简介</h2><p>SMPL(Skinned Multi-Person Linear (SMPL) Model）是一种，用<strong>形状参数</strong>和<strong>姿势参数</strong>来对人体进行编码的模型。</p><ul><li>形状参数：10个标量构成的向量。每个标量可以简单地理解为人体沿某方向的膨胀或收缩度。更准确的描述是主成分，也就是PCA主成分分析里面的主成分。</li><li>姿势参数：24个关节</li></ul><h2 id="姿态参数θ"><a href="#姿态参数θ" class="headerlink" title="姿态参数θ"></a>姿态参数θ</h2><blockquote><p>24*3: 24个关节的旋转角度</p></blockquote><ul><li><p>姿态参数θ：24个关节。其中23个非根关节相对父节点的旋转角度的轴角式表达(axis-angle representation)。<em>根节点存疑？？</em></p></li><li><p>这里的轴角式用三元数表示：$θ = (x,y,z) = θe$。 含义是以其单位向量<strong>e</strong>为旋转轴， 旋转大小是$|θ|$。（似乎是右手定则旋转）</p></li></ul><p>姿态的纠正：<br>    通过视觉方法等，实现2D的姿态估计，然后转到3D（或者其他原因），可能导致3D姿态不对（不是正常人能做出来的动作）。</p><p>通常的纠正方法包括：</p><ol><li>收集大规模正常人体活动数据，学习正常人姿态的范围，然后手动限制关节旋转角度</li><li>用大规模数据集做GAN的训练，训练一个<code>discrininator</code>来判定是不是正常动作</li></ol><h2 id="形状参数β："><a href="#形状参数β：" class="headerlink" title="形状参数β："></a>形状参数β：</h2><blockquote><p>把人体形状（6890个mesh vertices的位置）提取出10个主成分。每个主成分对应的取值，构成参数β；SMPL的第一个主成分大概类似于高矮，或者是整体的size。第二个大概是胖瘦。</p></blockquote><h1 id="人体合成管道（Human-synthesis-pipeline）"><a href="#人体合成管道（Human-synthesis-pipeline）" class="headerlink" title="人体合成管道（Human synthesis pipeline）"></a>人体合成管道（Human synthesis pipeline）</h1><p>三个阶段</p><h2 id="Shape-Blend-Shapes"><a href="#Shape-Blend-Shapes" class="headerlink" title="Shape Blend Shapes"></a>Shape Blend Shapes</h2><p>一句话总结：根据形状参数 $ \beta $，调节人体身材。</p><p>输入：基模板，<br>输出：静默姿态（(rest pose，也可以称之为T-pose)）下的人体mesh, 称为$V_{shape}$</p><p>计算方法：$V_{shape}=D\beta + \overline{T}$</p><p>其中，</p><ul><li><p>$\overline{T}$是基模板 ，是根据大量真实人体mesh得到的均值。用N = 6890个端点(vertex)表示整个mesh，每个端点有着x,y,z三个空间坐标</p></li><li><p>$\beta$​：形状参数，10个标量构成的向量，即 $\beta \in \mathbb{R}^{10}$</p></li><li><p>$D \in \mathbb{R}^{6890 \times 3 \times 10 }$是10个主成分的偏移方向（常量）:主要形状成分(Principal Shape Components)或者称之为端点偏移(Vertex Deviations)。（没仔细看，感觉应该是主成分分析PCA计算得到的吧）</p><ul><li>可以理解为，一共有10个主成分（对应10个β参数），有的控制高矮，有的控制胖瘦，有的控制小肚子，有的控制腿等。</li><li>每个主成分包含6890个顶点的偏移方向，比如往上是长高，往外是变胖。这个偏移方向乘以偏移大小β，得到最终的相对于T的偏移。</li><li>比如下图左右分别是第一个和第二个主成分的样子。</li><li>可以猜想，第一个主成分的6890个点的坐标位置会变高，即便宜方向D是向上的。第二个主成分的便宜方向是向外的。</li></ul><p><img src="C:\Users\Mirclea\AppData\Roaming\Typora\typora-user-images\image-20220923154831949.png" alt="偏置值对于形体的影响"></p></li></ul><p>根据形状参数β，调节人体mesh的高矮胖瘦</p><h2 id="Pose-Blend-Shapes"><a href="#Pose-Blend-Shapes" class="headerlink" title="Pose Blend Shapes"></a>Pose Blend Shapes</h2><p>​    特定动作会影响人体形状，比如坐着比站着更容易有小肚子。因此这一步就是加上姿态参数θ对身材的影响（还是求的静默姿态）。 也即，关节旋转导致其周围的mesh顶点的变形。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v_posed = v_shaped + self.posedirs.dot(lrotmin)</span><br></pre></td></tr></table></figure><ul><li><code>v_posed</code> : 6890x3 经过这一步计算以后得到的所有mesh顶点的$xyz$坐标。</li><li><code>v_shaped</code> ：上一步计算得到的 $V_{shape}$</li><li><code>lrotmin(R)</code>： 23×9的旋转矩阵。将由轴角式的$\theta(23×3)$ 转换得到的23×9的旋转矩阵。</li><li><code>self.posedirs</code>: 6890×3 ×23×9 常量，类似于上面shape blend里面的D。$D \in \mathbb{R}^{6890 \times 3 \times 10}$ 是10个β参数对6890×3 的mesh顶点位置的影响。而我们的23×9的关节旋转对顶点位置的影响就用<code>posedirs</code>表示。这个值是通过数据集训练学习得到的。</li></ul><h2 id="蒙皮"><a href="#蒙皮" class="headerlink" title="蒙皮"></a>蒙皮</h2><ul><li>前两步计算得到的都是$T_{pose}$下面的mesh。接下来需要蒙皮，即“<strong>让mesh vertices 即skin，跟随关节点进行移动</strong>”。</li><li>具体来说，需要根据全局关节变换（旋转和平移）的加权组合来变换。</li><li>其中关节旋转上面已经有了，就是$\theta$或者是旋转矩阵$R$。</li></ul><h3 id="关节位置估算-joint-Locations-Estimation"><a href="#关节位置估算-joint-Locations-Estimation" class="headerlink" title="关节位置估算  joint Locations Estimation"></a>关节位置估算  joint Locations Estimation</h3><p>刚才我们由10个shape参数$\beta$ 和24*3个$\theta$参数，求出了所有mesh vertices的位置。但我们还没给出所有joint关节的位置。</p><p>在SMPL模型中，关节位置由周围顶点的坐标加权得到。权重$J_{regressor}$是从数据集中学习的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># v_shape:          6890x3    the mesh in neutral T-pose calculated from a shape parameter of 10 scalar values.</span></span><br><span class="line"><span class="comment"># self.J_regressor: 24x6890   the regression matrix that maps 6890 vertex to 24 joint locations</span></span><br><span class="line"><span class="comment"># self.J:           24x3      24 joint (x,y,z) locations</span></span><br><span class="line">self.J = self.J_regressor.dot(v_shaped)</span><br></pre></td></tr></table></figure><p>这样，我们就求出了$T_{pose}$下，每个关节的坐标。接下来在此基础上需要改变pose。</p><h3 id="蒙皮变形-skinning-deformation"><a href="#蒙皮变形-skinning-deformation" class="headerlink" title="蒙皮变形 skinning deformation"></a>蒙皮变形 skinning deformation</h3><ul><li><p>将每个joint变换到目标pose。</p><ul><li>依此累乘父关节的变换矩阵R即可得到相对于$T_{pose}$的全局变换。</li></ul></li><li><p>将每个<code>mesh vertix</code>变换到目标pose</p><ul><li>每个<code>vertix</code>位置是24个关节位置加权的结果。权重weights : (6890, 24)</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL(2)</title>
      <link href="/2022/09/20/OpenGL(2)/"/>
      <url>/2022/09/20/OpenGL(2)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在学习此节之前，建议将这三个单词先记下来：</p><ul><li>顶点数组对象：Vertex Array Object，VAO</li><li>顶点缓冲对象：Vertex Buffer Object，VBO</li><li>元素缓冲对象：Element Buffer Object，EBO 或 索引缓冲对象 Index Buffer Object，IBO</li></ul></blockquote><h2 id="绘制三角形"><a href="#绘制三角形" class="headerlink" title="绘制三角形"></a>绘制三角形</h2><p>在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。</p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV(二)</title>
      <link href="/2022/09/19/OpenCV2/"/>
      <url>/2022/09/19/OpenCV2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章主要讲解了openCV对图像的平滑去噪的处理基础</p></blockquote><h2 id="滤波操作"><a href="#滤波操作" class="headerlink" title="滤波操作"></a>滤波操作</h2><p>卷积操作，通过像素卷积核对其核内的数值进行相关的数值变换操作</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220919162408220.png" alt="滤波卷积核展示"></p><p>这里是通过一定的<strong><em>规则</em></strong>，对于一组卷积核内的数值进行变换进行滤波</p><p>原始数据：<img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220919161920805.png" alt="初始数据图片"></p><blockquote><p>这张图片好像不是带杂音的图像，读者可以自己去找一找一张带杂讯的图片</p></blockquote><h3 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h3><p>openCV中可以使用<code>blur</code>函数对数据进行均值滤波</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blur = cv2.blur(img, (<span class="number">3</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><p><code>cv2.blur(image,kernel_size)</code>的两个参数<code>image</code>代表要处理的文件，<code>kernel_size</code>代表在滤波过程中使用的卷积核大小(最好使用奇数大小)</p><p>均值滤波实际上是对于卷积核内的数值相加再取<strong>算数均值</strong>填入卷积核最中间的格子中</p><h3 id="方框滤波"><a href="#方框滤波" class="headerlink" title="方框滤波"></a>方框滤波</h3><p>和均值率波的计算过程是一样的，不过可以添加<strong>正则化处理</strong>和大小越界</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box = cv2.boxFilter(img, -<span class="number">1</span>, (<span class="number">3</span>, <span class="number">3</span>), normalize=<span class="literal">True</span>) <span class="comment"># 第二个参数 为颜色通道统一，填入-1即可</span></span><br></pre></td></tr></table></figure><p>如果不加<code>normalize=True</code>或者设置<code>normalize=False</code>那么对于方框滤波就不会取均值而是取和，很容故意发生越界现象，比如下图：</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220919164253164.png" alt="不加正则化后的方框滤波处理"></p><h3 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h3><p>可理解为根据离卷积核中间的距离可以判断远近，通过高斯概率分布赋予对应方格权值，在进行计算<strong>加权均值</strong>填入卷积核中间的格子中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gaussian = cv2.GaussianBlur(img, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>最后的一个参数代表是正态分布的标准差为1</p></blockquote><h3 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h3><blockquote><p>对中间值取kernel中的值的中位数替换</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">median = cv2.medianBlur(img, <span class="number">5</span>)  <span class="comment">#第二个参数为kernel_size,这个5代表(5,5)</span></span><br></pre></td></tr></table></figure><h4 id="tip（图片拼接显示）"><a href="#tip（图片拼接显示）" class="headerlink" title="tip（图片拼接显示）"></a>tip（图片拼接显示）</h4><p>利用<code>np.hstack()</code>可以实现多组图像的水平拼接显示，而利用<code>np.vstack()</code>可以实现垂直拼接实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">figure_splicing</span>(<span class="params">images</span>):</span><br><span class="line">    res = np.hstack(images)<span class="comment"># res = np.vstack(images)</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = utils.figure_splicing((img, blur, gaussian, median))</span><br><span class="line">utils.show_image(<span class="string">&#x27;r&#x27;</span>, res)</span><br></pre></td></tr></table></figure><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220919171009056.png" alt="对比结果"></p><blockquote><p>四个图像依次是：原图、均值滤波、高斯滤波、中值滤波</p></blockquote><h2 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h2><h3 id="腐蚀操作"><a href="#腐蚀操作" class="headerlink" title="腐蚀操作"></a>腐蚀操作</h3><p>注意 ： <strong>腐蚀操作的对象通常是二值图</strong></p><p>类似与上面的滤波操作，腐蚀操作也有一个腐蚀核，对于一个腐蚀核，如果腐蚀核中有黑又白，那么将核中将白点全部涂黑，黑点不变（从图像开始检索，到检索玩这张图为一个迭代）</p><p>读入二值图像 利用<code>ret,dst=cv2.threshold(src,thresh,maxval,type)</code> (上一章有讲到)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;../img/fs.png&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这个项目没用的原因是因为图片本身就是二值图，不需要再根据函数得到二值图</p></blockquote><p>腐蚀操作的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), np.uint8)</span><br><span class="line">erosion = cv2.erode(img, kernel, iterations=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>对于腐蚀操作<code>cv2.erode()</code>的三个参数，第一个略过：</p><ul><li>第二个：kernel，腐蚀核的大小</li><li>第三个：iterations，迭代次数，迭代此时对于结果影像如下图</li></ul><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220919173712644.png" alt="迭代次数对于结果的影响"></p><p>对应的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">erosion1 = cv2.erode(img, kernel, iterations=<span class="number">1</span>)</span><br><span class="line">erosion2 = cv2.erode(img, kernel, iterations=<span class="number">2</span>)</span><br><span class="line">erosion3 = cv2.erode(img, kernel, iterations=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">res = utils.figure_splicing((img, erosion1, erosion2, erosion3))</span><br><span class="line">utils.show_image(<span class="string">&quot;对比&quot;</span>, res)</span><br></pre></td></tr></table></figure><blockquote><p>上述四图依次是原图、迭代1次、迭代2次、迭代3次的结果 ，其中kernel 保持为（5，5）</p><p>腐蚀核大小对于结果的影响这里就不在给出，读者若有兴趣可以自行尝试，或者取我的GitHub上查看源码</p></blockquote><h3 id="膨胀操作"><a href="#膨胀操作" class="headerlink" title="膨胀操作"></a>膨胀操作</h3><p>膨胀操作是腐蚀操作的逆操作，膨胀核中只要存在白点就要将核中黑点染白，其他于腐蚀操作类似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), np.uint8)</span><br><span class="line">dilate = cv2.dilate(img, kernel, iterations=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>膨胀操作的基本代码，参数于腐蚀操作的参数一样这里就不再介绍</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">j0 = img = cv2.imread(<span class="string">&#x27;../img/fs.png&#x27;</span>)</span><br><span class="line">kernel1 = np.ones((<span class="number">3</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line">j1 = cv2.erode(j0, kernel1, iterations=<span class="number">10</span>)</span><br><span class="line">j2 = cv2.dilate(j1, kernel1, iterations=<span class="number">10</span>)</span><br><span class="line">res2 = utils.figure_splicing((j0, j1, j2))</span><br><span class="line">utils.show_image(<span class="string">&quot;process&quot;</span>, res2)</span><br></pre></td></tr></table></figure><p>上面的代码这是腐蚀与膨胀的结合产生的结果的代码，下图是最终呈现的效果</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220919183610396.png" alt="image-20220919183610396"></p><h3 id="开运算和闭运算"><a href="#开运算和闭运算" class="headerlink" title="开运算和闭运算"></a>开运算和闭运算</h3><ul><li>开运算：先腐蚀，再膨胀（结果见上一节的图像）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">j0 = img = cv2.imread(<span class="string">&#x27;../img/fs.png&#x27;</span>)</span><br><span class="line">kernel1 = np.ones((<span class="number">3</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line">j1 = cv2.erode(j0, kernel1, iterations=<span class="number">10</span>)</span><br><span class="line">j2 = cv2.dilate(j1, kernel1, iterations=<span class="number">10</span>)</span><br><span class="line">res2 = utils.figure_splicing((j0, j1, j2))</span><br><span class="line">utils.show_image(<span class="string">&quot;process&quot;</span>, res2)</span><br></pre></td></tr></table></figure><ul><li>闭运算：先膨胀，再腐蚀</li></ul><p>结果如下：<img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220919185435402.png" alt="image-20220919185435402"></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kernel2 = np.ones((<span class="number">3</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line">ji1 = cv2.dilate(j0, kernel2, iterations=<span class="number">10</span>)</span><br><span class="line">ji2 = cv2.erode(ji1, kernel2, iterations=<span class="number">10</span>)</span><br><span class="line">res3 = utils.figure_splicing((j0, ji1, ji2))</span><br><span class="line">utils.show_image(<span class="string">&quot;process&quot;</span>, res3)</span><br></pre></td></tr></table></figure><h3 id="梯度计算"><a href="#梯度计算" class="headerlink" title="梯度计算"></a>梯度计算</h3><p>梯度 = 膨胀 - 腐蚀</p><p>代码描述</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradient = cv2.morphologyEx(pie, cv2.MORPH_GRADIENT, kernel)</span><br></pre></td></tr></table></figure><ul><li>pie : 传入图片</li><li>第二个参数为计算模式，这里是计算梯度</li><li>传入的核大小</li></ul><blockquote><p>我们注意这个函数是对于操作模式的封装其原因为<code>cv2.morphologyEx(src, op, kernel)</code>,作用是对于多种形态学的运算，三个参数分别是</p><ul><li>src传入的图片</li><li>op进行变化的方式</li><li>kernel表示方框的大小</li></ul><p>op = cv2.MORPH_OPEN 进行开运算，指的是先进行腐蚀操作，再进行膨胀操作</p><p>op = cv2.MORPH_CLOSE 进行闭运算， 指的是先进行膨胀操作，再进行腐蚀操作</p><p>op的值可以点击<a href="https://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/opening_closing_hats/opening_closing_hats.html">这里</a>了解更多</p></blockquote><h3 id="礼帽和黑帽"><a href="#礼帽和黑帽" class="headerlink" title="礼帽和黑帽"></a>礼帽和黑帽</h3><ul><li>礼帽=原始输入 - 开运算结果</li><li>黑帽=闭运算结果 - 原始输入</li></ul><p>对应<code>cv2.morphologyEx(src, op, kernel)</code>中的op值分别是：</p><ul><li>礼帽<code>op = cv2.MORPH_TOPHAT</code></li><li>黑帽<code>op= cv2.MORPH_BLACKHAT</code></li></ul><p>对于上述描述的形态学参数的计算我放在了一段代码中，如下段代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pie = cv2.imread(<span class="string">&#x27;../img/fs.png&#x27;</span>)</span><br><span class="line">pie = cv2.resize(pie, (<span class="number">200</span>, <span class="number">200</span>))</span><br><span class="line">kernel = np.ones((<span class="number">7</span>, <span class="number">7</span>), np.uint8)</span><br><span class="line"></span><br><span class="line">openNum = cv2.morphologyEx(pie, cv2.MORPH_OPEN, kernel)  <span class="comment"># 开运算</span></span><br><span class="line">closeNum = cv2.morphologyEx(pie, cv2.MORPH_CLOSE, kernel)  <span class="comment"># 闭运算</span></span><br><span class="line">gradient = cv2.morphologyEx(pie, cv2.MORPH_GRADIENT, kernel)  <span class="comment"># 梯度</span></span><br><span class="line">top = cv2.morphologyEx(pie, cv2.MORPH_TOPHAT, kernel)  <span class="comment"># 礼帽</span></span><br><span class="line">black = cv2.morphologyEx(pie, cv2.MORPH_BLACKHAT, kernel)  <span class="comment"># 黑帽</span></span><br><span class="line"></span><br><span class="line">res = utils.figure_splicing((pie, openNum, closeNum, gradient, top, black))</span><br><span class="line">utils.show_image(<span class="string">&#x27;images result&#x27;</span>, res)</span><br></pre></td></tr></table></figure></p><p>其运算的结果如下：</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220919193723637.png" alt="结果对比"></p><blockquote><p>五张图片依次是，原图、开运算结果、闭云算、梯度、礼帽、黑帽</p></blockquote><p>本篇文章中的代码我已经传入我的<a href="https://github.com/Mircela/LearnOpenCV.git">Github</a> ,若想查看代码请移步至我的GitHub</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex入门</title>
      <link href="/2022/09/18/Latex/"/>
      <url>/2022/09/18/Latex/</url>
      
        <content type="html"><![CDATA[<h3 id="latex的vscode配置"><a href="#latex的vscode配置" class="headerlink" title="latex的vscode配置"></a>latex的vscode配置</h3><ul><li>下载latex镜像文件，下载地址点击<a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/">这里</a>可以进入</li></ul><p>​    这里我下载的是下面的这一个</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220919124920806.png" style="zoom:90%;" /></p><blockquote><p>对于这种.iso文件直接利用win10自带的虚拟光驱打开即可，不需要再额外下载其他虚拟光驱软件</p></blockquote><ul><li>配置vscode setting文件</li></ul><script type="math/tex; mode=display">打开vscode 左下角设置\rightarrow右上角打开设置(json)\rightarrow将下列代码粘贴至json文件中</script><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;latex-workshop.latex.autoBuild.run&quot;</span><span class="punctuation">:</span> <span class="string">&quot;never&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.showContextMenu&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.intellisense.package.enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.message.error.show&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.message.warning.show&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latexmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latexmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-pdf&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-outdir=%OUTDIR%&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.recipes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;XeLaTeX&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PDFLaTeX&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;pdflatex&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BibTeX&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;bibtex&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LaTeXmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;latexmk&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex -&gt; bibtex -&gt; xelatex*2&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex -&gt; bibtex -&gt; pdflatex*2&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;pdflatex&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.clean.fileTypes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;*.aux&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.bbl&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.blg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.idx&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.ind&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.lof&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.lot&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.out&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.toc&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.acn&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.acr&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.alg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.glg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.glo&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.gls&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.ist&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.fls&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.log&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.fdb_latexmk&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.autoClean.run&quot;</span><span class="punctuation">:</span> <span class="string">&quot;onFailed&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.recipe.default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lastUsed&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.internal.synctex.keybinding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;double-click&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.viewer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tab&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.external.viewer.command&quot;</span><span class="punctuation">:</span></span><br><span class="line"><span class="string">&quot;D:/Tool/SumatraPDF/SumatraPDF.exe&quot;</span><span class="punctuation">,</span>  <span class="comment">//注意修改路径</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.external.viewer.args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;%PDF%&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.external.synctex.command&quot;</span><span class="punctuation">:</span></span><br><span class="line"><span class="string">&quot;D:/Tool/SumatraPDF/SumatraPDF.exe&quot;</span><span class="punctuation">,</span>  <span class="comment">//注意修改路径</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.external.synctex.args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;-forward-search&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;%TEX%&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;%LINE%&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;%PDF%&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><blockquote><p>直接复制到vscode的setting.json的大括号之中（注意修改配置的路径）、</p></blockquote><h3 id="latex语法"><a href="#latex语法" class="headerlink" title="latex语法"></a>latex语法</h3><p>由于latex语法比较多且有点乱(本人学的也不太明白)，</p><p>我们可以通过<a href="https://github.com/CTeX-org/lshort-zh-cn">这里</a>找到latex手册进行学习</p><p>一些简单的常用的语法建议看一下这个<a href="https://www.bilibili.com/video/BV11h41127FD?from=search&amp;seid=12274189218691696421&amp;spm_id_from=333.337.0.0&amp;vd_source=57e5130c3375ea877ab660ca10500f21">视频</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openGLVscode配置</title>
      <link href="/2022/09/17/openGL-config/"/>
      <url>/2022/09/17/openGL-config/</url>
      
        <content type="html"><![CDATA[<h2 id="参考步骤"><a href="#参考步骤" class="headerlink" title="参考步骤"></a>参考步骤</h2><ul><li>windows 需安装 MinGW, install gcc、g++、gdb 和 mingw32-make 并 进入到 <code>MinGW\bin</code> 文件夹下 把 mingw32-make.exe 修改成 make.exe</li></ul><blockquote><p><a href="https://sourceforge.net/projects/mingw/">MinGW</a> 不要下载 <em>MinGW-w64</em>因为后面可能会出现问题 MinGW，即 Minimalist GNU For Windows。它是一些头文件和端口库的集合，该集合允许人们在没有第三方动态链接库的情况下使用 GCC 产生 Win32 程序。</p></blockquote><ul><li><p>vscode 插件 <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools"><code>C/C++</code></a>、<a href="https://marketplace.visualstudio.com/items?itemName=danielpinto8zz6.c-cpp-project-generator"><code>C/C++ Project Generator</code></a></p></li><li><p>glfw 下载 <a href="https://www.glfw.org/download.html"><code>Windows pre-compiled binaries</code></a></p></li></ul><blockquote><p>选择<strong>Windows pre-compiled binaries</strong>，因为我们使用的 MinGW 所以选择 <a href="https://github.com/glfw/glfw/releases/download/3.3.4/glfw-3.3.4.bin.WIN32.zip">32-bit Windows binaries</a> </p></blockquote><ul><li>glad <a href="https://glad.dav1d.de/">在线服务</a> 生成静态库</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc ./src/glad.c -c -I ./include/ // 生成 .o文件</span><br><span class="line">&gt; ar -rc libglad.a glad.o           // 生成我们所需要的 .a文件</span><br></pre></td></tr></table></figure><blockquote><p>将生成的 libglad.a 复制到 lib 文件下</p></blockquote><ul><li>glm 复制到 include 目录下</li><li>imgui 复制到 include 目下,Makefile 中添加以下命令</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># define the C source files</span></span><br><span class="line">SOURCES:= <span class="variable">$(<span class="built_in">wildcard</span> $(<span class="built_in">patsubst</span> %,%/*.cpp, <span class="variable">$(SOURCEDIRS)</span>)</span>)</span><br><span class="line">SOURCES+= <span class="keyword">include</span>/imgui/imgui_impl_glfw.cpp <span class="keyword">include</span>/imgui/imgui_impl_opengl3.cpp</span><br><span class="line">SOURCES+= <span class="keyword">include</span>/imgui/imgui.cpp <span class="keyword">include</span>/imgui/imgui_demo.cpp <span class="keyword">include</span>/imgui/imgui_draw.cpp <span class="keyword">include</span>/imgui/imgui_widgets.cpp</span><br></pre></td></tr></table></figure><ul><li><p>assimp 下载已编译好的文件 <a href="https://www.mediafire.com/file/jjiv41rv8euy3dt/Assimp3-1-1_MinGW4-8-1_Win32.zip/file">Assimp3-1-1_MinGW4-8-1_Win32.zip</a></p></li><li><p><a href="https://github.com/yocover/start-learning-opengl/blob/main/Makefile">参考 Makefile 文件</a></p></li></ul><h2 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h2><h3 id="1-Run-和-Clean"><a href="#1-Run-和-Clean" class="headerlink" title="1. Run 和 Clean"></a>1. Run 和 Clean</h3><p><strong>测试代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glfwInit</span>();</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">processInput</span>(window);</span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"><span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line"><span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行命令 run 编译和运行.exe 程序</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make run <span class="built_in">dir</span>=<span class="number">01</span>_test_glfw</span><br></pre></td></tr></table></figure><p><strong>执行命令 clean 删除 .exe 和对应文件夹下的.o 文件</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean <span class="built_in">dir</span>=<span class="number">01</span>_test_glfw</span><br></pre></td></tr></table></figure><h3 id="2-Debug"><a href="#2-Debug" class="headerlink" title="2. Debug"></a>2. Debug</h3><p>需要设置调试一个文件 修改 <code>tasks.json</code>下面的条目</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;windows&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;powershell&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">         <span class="string">&quot;-c&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="string">&quot;make dir=01_test_glfw&quot;</span><span class="punctuation">,</span> <span class="comment">// 调式 01_test_glfw/main.cpp</span></span><br><span class="line">     <span class="punctuation">]</span></span><br><span class="line"> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>​    主要参考视频：<a href="https://www.bilibili.com/video/BV1BX4y1g7R6?vd_source=57e5130c3375ea877ab660ca10500f21">VsCode下配置OpenGL开发环境</a></p><p>​    文字参考：<a href="https://github.com/yocover/start-learning-opengl">VsCode下配置OpenGL开发环境GitHub</a></p><blockquote><p>若按照上面视频出现包路径找不到，可以把对应的.a以及.h文件直接复制到MinGW路径下对应lib文件夹和include文件夹</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV(一)</title>
      <link href="/2022/09/16/OpenCV1/"/>
      <url>/2022/09/16/OpenCV1/</url>
      
        <content type="html"><![CDATA[<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python==xx.xx</span><br><span class="line">pip insatll opencv-contrib-python==xx.xx</span><br></pre></td></tr></table></figure><blockquote><p>注意两个包的版本号要相同</p></blockquote><h3 id="读取图片"><a href="#读取图片" class="headerlink" title="读取图片"></a>读取图片</h3><blockquote><p>opencv读入的图片默认是RBG格式的，若要用matplotlib画图需要转成RGB格式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">r&#x27;./img/2.jpg&#x27;</span>) <span class="comment"># 读入图片</span></span><br><span class="line"><span class="built_in">type</span>(img)</span><br><span class="line"><span class="comment"># &lt;class &#x27;numpy.ndarray&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>一般来说，图片的存储形式为三维矩阵(宽 <em> 高 </em> 颜色通道数)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 展示图片</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;image&#x27;</span>, img) <span class="comment"># 窗口名字、图像矩阵</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>) <span class="comment"># 等待自动关闭时间（ms级别），使用0代表手动关闭，按任意一个键关闭</span></span><br><span class="line">cv2.destoryAllWindows() <span class="comment"># 关闭窗口</span></span><br></pre></td></tr></table></figure><p>封装一下展示图片的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">show_image</span>(<span class="params">windows_name, image</span>):</span><br><span class="line">    cv2.imshow(windows_name, image)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h4 id="灰度图"><a href="#灰度图" class="headerlink" title="灰度图"></a>灰度图</h4><p> 读取灰度图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image2 = cv2.imread(<span class="string">r&#x27;./img/2.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br></pre></td></tr></table></figure><p> 在图像读取中添加一个第二参数<code>cv2.IMREAD_GRAYSCALE</code>,代表读取该图像的灰度图</p><p>对比代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">image1 = cv2.imread(<span class="string">r&#x27;./img/2.jpg&#x27;</span>)</span><br><span class="line">image2 = cv2.imread(<span class="string">r&#x27;./img/2.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="built_in">print</span>(image1.shape)</span><br><span class="line"><span class="built_in">print</span>(image2.shape)</span><br><span class="line">show_image(<span class="string">&#x27;img1&#x27;</span>, image1)</span><br><span class="line">show_image(<span class="string">&#x27;img2&#x27;</span>, image2)</span><br></pre></td></tr></table></figure><p>这个可以看到，输出的<code>image1.shape=(w,h,3)</code>而<code>image2.shape=(w,h)</code>并且图片也从彩色图片变成黑白图片。</p><h3 id="读取视频"><a href="#读取视频" class="headerlink" title="读取视频"></a>读取视频</h3><blockquote><p>视频实际上就是多张图片按照先后顺序依次展示的样子。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vc = cv2.VideoCapture(<span class="string">r&#x27;./img/1.mp4&#x27;</span>)  <span class="comment"># 读取视频</span></span><br><span class="line"><span class="keyword">if</span> vc.isOpened(): <span class="comment"># 检查是否可以打开</span></span><br><span class="line">    opened, frame = vc.read()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    opened = <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>  对于一个已经打开的视频，每一次读取都会读到一帧的静态图像 <code>opened, frame = vc.read()</code>    (两个参数，一个是不是视频的有效帧、一个是图像帧)</p><p>视频展示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vc = cv2.VideoCapture(<span class="string">r&#x27;./img/1.mp4&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> vc.isOpened():</span><br><span class="line">    opened, frame = vc.read()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    opened = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 视频展示</span></span><br><span class="line"><span class="keyword">while</span> opened:</span><br><span class="line">    ret, frame = vc.read()</span><br><span class="line">    <span class="keyword">if</span> frame <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">       <span class="keyword">break</span></span><br><span class="line">     <span class="keyword">if</span> ret == <span class="literal">True</span>:</span><br><span class="line">       gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) <span class="comment"># 图像转化成灰度图</span></span><br><span class="line">       cv2.imshow(<span class="string">&#x27;result&#x27;</span>,gray)</span><br><span class="line">       <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>: <span class="comment"># 调整视频播放倍速</span></span><br><span class="line">breakvc.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><blockquote><p>从上面可以看到，通常我们说的对于视频的处理，实际上是对于每一帧的图像进行处理。</p></blockquote><h3 id="图像的颜色通道"><a href="#图像的颜色通道" class="headerlink" title="图像的颜色通道"></a>图像的颜色通道</h3><h4 id="切分颜色通道"><a href="#切分颜色通道" class="headerlink" title="切分颜色通道"></a>切分颜色通道</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b, g, r = cv2.split(image) <span class="comment"># (576, 1024, 3)</span></span><br><span class="line"><span class="built_in">print</span>(b.shape) <span class="comment"># (576, 1024)</span></span><br><span class="line"><span class="built_in">print</span>(g.shape) <span class="comment"># (576, 1024)</span></span><br><span class="line"><span class="built_in">print</span>(r.shape) <span class="comment"># (576, 1024)</span></span><br></pre></td></tr></table></figure><h4 id="合并颜色通道"><a href="#合并颜色通道" class="headerlink" title="合并颜色通道"></a>合并颜色通道</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">im = cv2.merge((b, g, r)) <span class="comment"># (576, 1024)</span></span><br><span class="line"><span class="built_in">print</span>(im.shape) <span class="comment"># (576, 1024, 3)</span></span><br></pre></td></tr></table></figure><h4 id="单通道提取"><a href="#单通道提取" class="headerlink" title="单通道提取"></a>单通道提取</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image = cv2.imread(<span class="string">r&#x27;./img/2.jpg&#x27;</span>)</span><br><span class="line">cur_img = image.copy()</span><br><span class="line">cur_img[:, :, <span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">cur_img[:, :, <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">show_image(<span class="string">&#x27;r&#x27;</span>, cur_img)</span><br></pre></td></tr></table></figure><blockquote><p>注意：（0,1,2）=== （b,g,r）这和一般我们的思想rgb不同</p></blockquote><h3 id="边界填充"><a href="#边界填充" class="headerlink" title="边界填充"></a>边界填充</h3><p>  cv2中一共有五种边界填充方式(replicate、reflect、reflect101、wrap、constant)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">top, right, left, bottom = (<span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">replicate = cv2.copyMakeBorder(img, top, bottom, left, right, </span><br><span class="line">                               borderType=cv2.BORDER_REPLICATE)</span><br><span class="line">reflect = cv2.copyMakeBorder(img, top, bottom, left, right, </span><br><span class="line">                             borderType=cv2.BORDER_REFLECT)</span><br><span class="line">reflect101 = cv2.copyMakeBorder(img, top, bottom, left, right, </span><br><span class="line">                                borderType=cv2.BORDER_REFLECT_101)</span><br><span class="line">wrap = cv2.copyMakeBorder(img, top, bottom, left, right, borderType=cv2.BORDER_WRAP)</span><br><span class="line">constant = cv2.copyMakeBorder(img, top, bottom, left, right, </span><br><span class="line">                              borderType=cv2.BORDER_CONSTANT, value=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><ul><li>BORDER_REPLICATE : 复制法，复制最边缘的像素点进行填充</li><li>BORDER_REFLECT：反射法，对感兴趣的图像中的像素在两边进行复制例如：fedcba|abcdefgh|hgfedcb</li><li>BORDER_REFLECT_101：以最边缘的像素为轴做对称如：hgfedcb|abcdefgh|gfedcba</li><li>BORDER_WRAP：外包装法，如：cdefgh|abcdefgh|abcdefg</li><li>BORDER_CONSTANT：常量填充</li></ul><h3 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h3><ul><li>直接在读出的图像矩阵加常数，对数据图像矩阵的所有值都进行加上这个常数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img1 = cv2.imread(<span class="string">r&#x27;./img/2.jpg&#x27;</span>)</span><br><span class="line">img2 = img1 + <span class="number">10</span></span><br></pre></td></tr></table></figure><ul><li>将两图像（规格相同）直接相加（用+号相加），对应数值相加并且若和 <code>s&gt;255</code> 则 <code>s=s%256</code> </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img3 = img1 + img2</span><br><span class="line"><span class="comment"># img1.shape = img2.shape = (576, 1024, 3)</span></span><br></pre></td></tr></table></figure><ul><li>利用<code>cv2.add()</code>对两个图像相加，对应数值相加，若 <code>s&gt;255</code> 则 <code>s=255</code> </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img4 = cv2.add(img1, img2)</span><br></pre></td></tr></table></figure><h4 id="图像融合"><a href="#图像融合" class="headerlink" title="图像融合"></a>图像融合</h4><blockquote><p>注意对于融合的图像大小规格要相同才可以进行融合，对于不同大小的图片进行融合我们需要利用<code>cv2.resize()</code> 来调整图片大小</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img1 = cv2.imread(<span class="string">r&#x27;./img/2.jpg&#x27;</span>) <span class="comment"># (576,1024,3)</span></span><br><span class="line">img2 = cv2.imread(<span class="string">r&#x27;./img/2-1.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line">img2 = cv2.resize(img2, (<span class="number">1024</span>, <span class="number">576</span>)) <span class="comment"># 注意参数的位置</span></span><br></pre></td></tr></table></figure><p><code>cv2.resize()</code> 的用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">show_image(<span class="string">&#x27;0&#x27;</span>, img1)</span><br><span class="line">res = cv2.resize(img1, (<span class="number">0</span>, <span class="number">0</span>), fx=<span class="number">2</span>, fy=<span class="number">1</span>) <span class="comment"># x轴方向伸展2倍</span></span><br><span class="line">show_image(<span class="string">&#x27;1&#x27;</span>, res)</span><br><span class="line">res = cv2.resize(img1, (<span class="number">0</span>, <span class="number">0</span>), fx=<span class="number">1</span>, fy=<span class="number">2</span>) <span class="comment"># y轴方向伸展2倍</span></span><br><span class="line">show_image(<span class="string">&#x27;2&#x27;</span>, res)</span><br><span class="line">res = cv2.resize(img1, (<span class="number">0</span>, <span class="number">0</span>), fx=<span class="number">1.5</span>, fy=<span class="number">1.5</span>) <span class="comment"># x、y轴同时伸展1.5倍</span></span><br><span class="line">show_image(<span class="string">&#x27;3&#x27;</span>, res)</span><br></pre></td></tr></table></figure><p>图像融合可以看成公式 </p><script type="math/tex; mode=display">R=αx_1+βx_2+b，其中x_1，x_2为输入图像,α、β为图像对应的权重，b为图像的亮度偏置值</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = cv2.addWeighted(img1, <span class="number">0.4</span>, img2, <span class="number">0.6</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><code>cv2.addWeighted(x1, α, x2, β, b)</code> 对应的参数</p><h3 id="阈值处理"><a href="#阈值处理" class="headerlink" title="阈值处理"></a>阈值处理</h3><p>二值化处理函数<code>ret,dst=cv2.threshold(src,thresh,maxval,type)</code> 对应的参数解释如下：</p><ul><li><code>src</code>: 输入图，只能输入<strong>单通道</strong>图像，通常是灰度图</li><li><code>dst</code>: 输出图</li><li><code>thresh</code>: 阈值,返回值中的<code>ret</code>就是该值</li><li><code>maxval</code>: 当像素超出阈值（或者是小于阈值，根据type决定）所赋予的值</li><li><code>type</code>: 二值化操作类型，包含5种类型：<ul><li><code>cv2.THRESH_BINARY</code> 超过阈值部分取 <code>maxval</code> （最大值），否则取0</li><li><code>cv2.THRESH_BINARY_INV</code> <code>cv2.THRESH_BINARY</code>的反转</li><li><code>cv2.THRESH_TRUNC</code> 大于阈值的部分设为阈值，否则不变</li><li><code>cv2.THRESH_TOZERO</code> 大于阈值的部分不变，否则设为0</li><li><code>cv2.THRESH_TOZERO_INV</code> <code>cv2.THRESH_TOZERO</code> 的反转</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ret, thresh1 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">ret, thresh2 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV)</span><br><span class="line">ret, thresh3 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TRUNC)</span><br><span class="line">ret, thresh4 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TOZERO)</span><br><span class="line">ret, thresh5 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TOZERO_INV)</span><br><span class="line">images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]</span><br><span class="line">names = [<span class="string">&quot;0&quot;</span>, <span class="string">&quot;THRESH_BINARY&quot;</span>, <span class="string">&quot;THRESH_BINARY_INV&quot;</span>, <span class="string">&quot;THRESH_TRUNC&quot;</span>, <span class="string">&quot;THRESH_TOZERO&quot;</span>, <span class="string">&quot;THRESH_TOZERO_INV&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">3</span>, i + <span class="number">1</span>)</span><br><span class="line">    plt.imshow(images[i], <span class="string">&quot;gray&quot;</span>)</span><br><span class="line">    plt.title(names[i])</span><br><span class="line">    plt.xticks([])</span><br><span class="line">    plt.yticks([])</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>输出的图像对比图</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220917112910109.png" alt="二值化模式对比图"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_String_API</title>
      <link href="/2022/09/12/javaString/"/>
      <url>/2022/09/12/javaString/</url>
      
        <content type="html"><![CDATA[<blockquote><p>字符串反转代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverseTestOne</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s).reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode(T4)</title>
      <link href="/2022/09/09/leetcode04/"/>
      <url>/2022/09/09/leetcode04/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-—-04"><a href="#LeetCode-—-04" class="headerlink" title="LeetCode —- 04"></a>LeetCode —- 04</h1><blockquote><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。算法的时间复杂度应该为 O(log (m+n)) 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length + nums2.length;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> find(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, n / <span class="number">2</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> find(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, n / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>) (left + right) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>) find(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, n / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] num1, <span class="type">int</span> i, <span class="type">int</span>[] num2, <span class="type">int</span> j, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num1.length - i &gt; num2.length - j) &#123;</span><br><span class="line">            <span class="keyword">return</span> find(num2, j, num1, i, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num1.length == i) &#123;</span><br><span class="line">            <span class="keyword">return</span> num2[j + k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> min(num1[i], num2[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx1</span> <span class="operator">=</span> min(num1.length, i + k / <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx2</span> <span class="operator">=</span> j + k - k / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (num1[idx1 - <span class="number">1</span>] &lt; num2[idx2 - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> find(num1, idx1, num2, j, k - (idx1 - i));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> find(num1, i, num2, idx2, k - (idx2 - j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码如上；</p><p>思路主要是利用了二分查找的思想，对于两个数组的总长度 l=l1+l2 奇偶的处理是不同的，这个题目实际上是求连个有序数组的第k大小的数。利用k=l/2(初始值)在每个数组中初始值都有设为i=k/2;j=k-k/2对比大小比较小的一部分明显是不合适的可以直接从数组中删除在更新新的k值完成递归</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL（一）</title>
      <link href="/2022/09/09/OpenGL(1)/"/>
      <url>/2022/09/09/OpenGL(1)/</url>
      
        <content type="html"><![CDATA[<p>本文中使用的代码链接 <a href="https://github.com/Mircela/LearnOpenGL.git">GitHub</a></p><h3 id="导入头文件"><a href="#导入头文件" class="headerlink" title="导入头文件"></a>导入头文件</h3><blockquote><p>当导入头文件的时候出现路径问题是，无法找到头文件路径，我们可以查看配置篇的<strong>注意</strong>部分</p></blockquote><p>对于头文件的引入会有要求，按照一下引入顺序进行引入操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br></pre></td></tr></table></figure></p><blockquote><p>请确认是在包含GLFW的头文件之前包含了GLAD的头文件。GLAD的头文件包含了正确的OpenGL头文件（例如<code>GL/gl.h</code>），所以需要在其它依赖于OpenGL的头文件之前包含GLAD。</p></blockquote><h3 id="初始化GLFW"><a href="#初始化GLFW" class="headerlink" title="初始化GLFW"></a>初始化GLFW</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwInit</span>();</span><br><span class="line"><span class="comment">// 设置主要版本和次要版本</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE,GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"><span class="comment">// glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);  MAC OS 系统要使用改行命令完成兼容操作</span></span><br></pre></td></tr></table></figure><p>​    我们在main函数中调用<code>glfwInit</code>函数来初始化GLFW，然后我们可以使用<code>glfwWindowHint</code>函数来配置GLFW。<code>glfwWindowHint</code>函数的第一个参数代表选项的名称，我们可以从很多以<code>GLFW_</code>开头的枚举值中选择；第二个参数接受一个整型，用来设置这个选项的值。该函数的所有的选项以及对应的值都可以在 <a href="http://www.glfw.org/docs/latest/window.html#window_hints">GLFW’s window handling</a> 这篇文档中找到。</p><h3 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h3><p>​    接下来我们创建一个窗口对象，这个窗口对象存放了所有和窗口相关的数据，而且会被GLFW的其他函数频繁地用到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>,<span class="number">600</span>,<span class="string">&quot;learnOpenGL&quot;</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(window == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;open wrong!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br></pre></td></tr></table></figure><p>​    <code>glfwCreateWindow</code>函数需要窗口的宽和高作为它的前两个参数。第三个参数表示这个窗口的名称（标题），这里我们使用<code>&quot;LearnOpenGL&quot;</code>，当然你也可以使用你喜欢的名称。最后两个参数我们暂时忽略。这个函数将会返回一个<code>GLFWwindow</code>对象，我们会在其它的GLFW操作中使用到。创建完窗口我们就可以通知GLFW将我们窗口的上下文设置为当前线程的主上下文了。</p><h3 id="初始化GLAD"><a href="#初始化GLAD" class="headerlink" title="初始化GLAD"></a>初始化GLAD</h3><p>​    GLAD是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLAD。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    我们给GLAD传入了用来加载系统相关的OpenGL函数指针地址的函数。GLFW给我们的是<code>glfwGetProcAddress</code>，它根据我们编译的系统定义了正确的函数。</p><h3 id="设置视口"><a href="#设置视口" class="headerlink" title="设置视口"></a>设置视口</h3><p>​    在我们开始渲染之前还有一件重要的事情要做，我们必须告诉OpenGL渲染窗口的尺寸大小，即视口(Viewport)，这样OpenGL才只能知道怎样根据窗口大小显示数据和坐标。</p><p>​    我们可以通过调用<code>glViewport</code>函数来设置窗口的<strong>维度</strong>(Dimension)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);</span><br></pre></td></tr></table></figure><p><code>glViewport</code>函数前两个参数控制窗口左下角的位置。第三个和第四个参数控制渲染窗口的宽度和高度（像素）。</p><p>​    我们实际上也可以将视口的维度设置为比GLFW的维度小，这样子之后所有的OpenGL渲染将会在一个更小的窗口中显示，这样子的话我们也可以将一些其它元素显示在OpenGL视口之外。</p><blockquote><p>OpenGL幕后使用<code>glViewport</code>中定义的位置和宽高进行2D坐标的转换，将OpenGL中的位置坐标转换为你的屏幕坐标。例如，OpenGL中的坐标(-0.5, 0.5)有可能（最终）被映射为屏幕中的坐标(200,450)。注意，处理过的OpenGL坐标范围只为-1到1，因此我们事实上将(-1到1)范围内的坐标映射到(0, 800)和(0, 600)。</p></blockquote><p>​    然而，当用户改变窗口的大小的时候，视口也应该被调整。我们可以对窗口注册一个回调函数(Callback Function)，它会在每次窗口大小被调整的时候被调用。这个回调函数的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br></pre></td></tr></table></figure><p>​    这个帧缓冲大小函数需要一个<code>GLFWwindow</code>作为它的第一个参数，以及两个整数表示窗口的新维度。每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    我们还需要注册这个函数，告诉GLFW我们希望每当窗口调整大小的时候调用这个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br></pre></td></tr></table></figure><p>​    当窗口被第一次显示的时候<code>framebuffer_size_callback</code>也会被调用。对于视网膜(Retina)显示屏，<code>width</code>和<code>height</code>都会明显比原输入值更高一点。</p><p>​    我们还可以将我们的函数注册到其它很多的回调函数中。比如说，我们可以创建一个回调函数来处理手柄输入变化，处理错误消息等。我们会在创建窗口之后，渲染循环初始化之前注册这些回调函数。</p><h3 id="渲染循环"><a href="#渲染循环" class="headerlink" title="渲染循环"></a>渲染循环</h3><p> 我们可不希望只绘制一个图像之后我们的应用程序就立即退出并关闭窗口。我们希望程序在我们主动关闭它之前不断绘制图像并能够接受用户输入。因此，我们需要在程序中添加一个while循环，我们可以把它称之为<strong><em>渲染循环(Render Loop)</em></strong>，它能在我们让GLFW退出前一直保持运行。下面几行的代码就实现了一个简单的渲染循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))&#123;</span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>glfwWindowShouldClose</code>函数在我们每次循环的开始前检查一次GLFW是否被要求退出，如果是的话该函数返回<code>true</code>然后渲染循环便结束了，之后为我们就可以关闭应用程序了。</li><li><code>glfwPollEvents</code>函数检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数（可以通过回调方法手动设置）。</li><li><code>glfwSwapBuffers</code>函数会交换颜色缓冲（它是一个储存着GLFW窗口每一个像素颜色值的大缓冲），它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。</li></ul><blockquote><p><strong>双缓冲(Double Buffer)</strong><br>应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。前缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在后缓冲上绘制。当所有的渲染指令执行完毕后，我们交换(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。</p></blockquote><h3 id="最后一件事"><a href="#最后一件事" class="headerlink" title="最后一件事"></a>最后一件事</h3><p>回收资源：我们可以在main函数的最后调用<code>glfwTerminate</code>函数来完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwTerminate</span>();</span><br></pre></td></tr></table></figure><p>我们运行程序，得到结果如下图所示，代表你的代码成功了</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220919112724199.png" alt="运行结果图"></p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>​    我们同样也希望能够在GLFW中实现一些输入控制，这可以通过使用GLFW的几个输入函数来完成。我们将会使用GLFW的<code>glfwGetKey</code>函数，它需要一个窗口以及一个按键作为输入。这个函数将会返回这个按键是否正在被按下。我们将创建一个<code>processInput</code>函数来让所有的输入代码保持整洁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        <span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这里我们检查用户是否按下了返回键(Esc)（如果没有按下，<code>glfwGetKey</code>将会返回<code>GLFW_RELEASE</code>。如果用户的确按下了返回键，我们将通过<code>glfwSetwindowShouldClose</code>使用把<code>WindowShouldClose</code>属性设置为 <code>true</code>的方法关闭GLFW。下一次while循环的条件检测将会失败，程序将会关闭。</p><p>​    我们接下来在渲染循环的每一个迭代中调用<code>processInput</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">processInput</span>(window); <span class="comment">// 渲染按键信息</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就给我们一个非常简单的方式来检测特定的键是否被按下，并在每一帧做出处理。</p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>​    我们要把所有的渲染(Rendering)操作放到渲染循环中，因为我们想让这些渲染指令在每次渲染循环迭代的时候都能被执行。代码将会是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染循环</span></span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 输入</span></span><br><span class="line">    <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染指令</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查并调用事件，交换缓冲</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    为了测试一切都正常工作，我们使用一个自定义的颜色清空屏幕。在每个新的渲染迭代开始的时候我们总是希望清屏，否则我们仍能看见上一次迭代的渲染结果（这可能是你想要的效果，但通常这不是）。我们可以通过调用<code>glClear</code>函数来清空屏幕的颜色缓冲，它接受一个缓冲位(Buffer Bit)来指定要清空的缓冲，可能的缓冲位有<code>GL_COLOR_BUFFER_BIT</code>，<code>GL_DEPTH_BUFFER_BIT</code>和<code>GL_STENCIL_BUFFER_BIT</code>。由于现在我们只关心颜色值，所以我们只清空颜色缓冲。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br></pre></td></tr></table></figure><p>注意，除了<code>glClear</code>之外，我们还调用了<code>glClearColor</code>来设置清空屏幕所用的颜色。当调用<code>glClear</code>函数，清除颜色缓冲之后，整个颜色缓冲都会被填充为<code>glClearColor</code>里所设置的颜色。在这里，我们将屏幕设置为了类似黑板的深蓝绿色。</p><blockquote><p><code>glClearColor</code>函数是一个<strong>状态设置</strong>函数，而<code>glClear</code>函数则是一个<strong>状态使用</strong>的函数，它使用了当前的状态来获取应该清除为的颜色。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/09/07/hello/"/>
      <url>/2022/09/07/hello/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
