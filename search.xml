<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>StyleGAN2</title>
      <link href="/2022/12/09/StyleGAN2/"/>
      <url>/2022/12/09/StyleGAN2/</url>
      
        <content type="html"><![CDATA[<h2 id="StyleGAN内容回顾"><a href="#StyleGAN内容回顾" class="headerlink" title="StyleGAN内容回顾"></a>StyleGAN内容回顾</h2><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221125140430697.png" alt="styleGAN模型"></p><p>分成两部分：</p><ul><li><p><code>Mapping network</code> </p></li><li><p><code>Synthesis network</code></p></li></ul><p>StyleGAN出现的问题：</p><ul><li>在训练的途中会出现的水滴残影，最后反映在图像中会使得图片部分出现不符合常理的阴影</li><li>在训练添加不同的噪声时，某些地方的无法受到噪声的影响</li></ul><h2 id="解决水滴阴影"><a href="#解决水滴阴影" class="headerlink" title="解决水滴阴影"></a>解决水滴阴影</h2><p>styleGAN2修改了styleGAN生成器的结构，来去除水滴阴影。</p><blockquote><p>导致水滴阴影的原因是 Adain 操作，Adain对每个feature map进行归一化，因此有可能会破坏掉feature之间的信息。</p></blockquote><p>文中去掉AdaIN修改生成器结构为</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221210142544226.png" alt="StyleGAN2的结构"></p><p>除了网络结构上的改进，还有就是<code>Weight demodulation</code>，公式如下：</p><script type="math/tex; mode=display">w_{i j k}^{\prime \prime}=w_{i j k}^{\prime} / \sqrt{\sum_{i, k} w_{i j k}^{\prime}{ }^2+\epsilon},\\w_{i j k}^{\prime} = s_i \cdot w_{ijk},\epsilon=10^{-8}</script><h2 id="训练优化以及图像质量优化"><a href="#训练优化以及图像质量优化" class="headerlink" title="训练优化以及图像质量优化"></a>训练优化以及图像质量优化</h2><h3 id="Lazy-regularization"><a href="#Lazy-regularization" class="headerlink" title="Lazy regularization"></a>Lazy regularization</h3><p>损失 是由损失函数和正则项组成，优化的时候也是同时优化这两项的，lazy regularization就是正则项可以减少优化的次数，比如每16个minibatch才优化一次正则项，这样可以减少计算量，同时对效果也没什么影响。</p><h3 id="Path-length-regularization"><a href="#Path-length-regularization" class="headerlink" title="Path length regularization"></a>Path length regularization</h3><p>在生成人脸的同时，我们希望能够控制人脸的属性，不同的latent code能得到不同的人脸，当确定latent code变化的具体方向时，该方向上不同的大小应该对应了图像上某一个具体变化的不同幅度。为了达到这个目的，设计了 Path length regularization ，它的原理也很简单，在图像上的梯度用图像乘上变换的梯度 来表示。</p><script type="math/tex; mode=display">\mathbb{E}_{\mathbf{w}, \mathbf{y} \sim \mathcal{N}(0, \mathbf{I})}\left(\left\|\mathbf{J}_{\mathbf{w}}^T \mathbf{y}\right\|_2-a\right)^2</script><h2 id="Progressive优化"><a href="#Progressive优化" class="headerlink" title="Progressive优化"></a>Progressive优化</h2><p>StyleGAN使用的Progressive growth会有一些缺点，如下图，当人脸向左右偏转的时候，牙齿却没有偏转，即人脸的一些细节如牙齿、眼珠等位置比较固定，没有根据人脸偏转而变化，造成这种现象是因为采用了Progressive growth训练，Progressive growth是先训练低分辨率，等训练稳定后，再加入高一层的分辨率进行训练，训练稳定后再增加分辨率，即每一种分辨率都会去输出结果，这会导致输出频率较高的细节忽视了的变化。</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221210152046059.png" alt=""></p><p>对于<code>progressive</code>的优化思路：使用Progressive growth的原因是高分辨率图像生成需要的网络比较大比较深，当网络过深的时候不容易训练，但是skip connection可以解决深度网络的训练，因此有了上图中的三种网络结构，都采用了skip connection。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StyleGAN</title>
      <link href="/2022/11/25/StyleGAN/"/>
      <url>/2022/11/25/StyleGAN/</url>
      
        <content type="html"><![CDATA[<h1 id="PGGAN"><a href="#PGGAN" class="headerlink" title="PGGAN"></a>PGGAN</h1><p>   <strong>Progressive Growing of GANs for Improved Quality, Stability, and Variation</strong> <em>Tero Karras, Timo Aila</em> <strong>Published 27 October 2017</strong>(Citations <strong>3711</strong>) 是 英伟达实验室 Tero Karras 大神提出的生成对抗网络模型，本文的中心思想是通过 Progressive Growing 的训练方法，加速训练过程并稳定模型，并取得非常好的实验效果。同时本还给出了提出了增加图片多样性，减少G和D恶性竞争的方法。以及衡量GAN的指标。</p><h2 id="网络架构"><a href="#网络架构" class="headerlink" title="网络架构"></a>网络架构</h2><p>​    这种渐进式的学习过程是从低分辨率开始，通过向网络中添加新的层逐步增加生成图片的分辨率。该种方法主观上允许我们首先学习图片分布的大的结构特征(低分辨率)，在机构特征学习之后，逐步学习图片的细节部分(高分辨率)，而不是同时学习所有尺度的特征。倘若同时学习所有尺度的特征网络的训练难度过大，试想当图片的大型结构仍需要继续学习，然而细节部分已经学习成功，又出现一个我们不想看到的问题，图片的大型结构一旦改变，网络的细节部分需要重新开始学习。从该角度来看，Progressive Growing 的网络训练架构是相当合理的。</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221125102644839.png" alt="PGGAN基础架构" style="zoom: 80%;" /></p><p>  因为网络训练的阶段性，倘若训练16x16直接转移到32x32的网络架构，因为新加入层的网络权重可能”很坏”，网络可能因此坏掉。为了解决该问题，PGGAN 设计了 fade in 的过渡流程。当16x16转移到32x32时，我们通过控制 $\alpha$ 因此，来实现一种渐进的过程，避免网络突然坏掉！</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221125102948478.png" alt=""></p><h1 id="StyleGAN"><a href="#StyleGAN" class="headerlink" title="StyleGAN"></a>StyleGAN</h1><p>StyleGAN中的“<strong>Style”</strong>是指数据集中人脸的主要属性，比如人物的姿态等信息，而不是风格转换中的图像风格，这里Style是指人脸的风格，包括了脸型上面的表情、人脸朝向、发型等等，还包括纹理细节上的人脸肤色、人脸光照等方方面面。具体的可以看上面给的效果视频链接，视频里不同的参数，可以控制人脸不同的“style”。StyleGAN 用风格（style）来影响人脸的姿态、身份特征等，用噪声 ( noise ) 来影响头发丝、皱纹、肤色等细节部分。</p><ul><li><strong>StyleGAN的第一点改进是，给Generator的输入加上了由8个全连接层组成的Mapping Network，并且 Mapping Network 的输出 W’ 与输入层（512×1）的大小相同。</strong></li><li><strong>StyleGAN 的第二点改进是，将特征解缠后的中间向量𝑊′变换为样式控制向量，从而参与影响生成器的生成过程。</strong></li></ul><h2 id="网络架构-1"><a href="#网络架构-1" class="headerlink" title="网络架构"></a>网络架构</h2><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221125140430697.png" alt="StyleGAN结构"></p><p>styleGAN的生成器两部分：</p><ul><li>Mapping network  $(f)$ :  用于将latent $z$ 转换成为 $w$</li><li>Synthesis network  $(g)$：用于生成图像</li></ul><h3 id="Mapping-network"><a href="#Mapping-network" class="headerlink" title="Mapping network"></a>Mapping network</h3><blockquote><p>为输入向量 $z$ 的特征<strong>解耦</strong>提供一条学习通道</p></blockquote><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221203104709323.png" alt=""></p><h3 id="Synthesis-network"><a href="#Synthesis-network" class="headerlink" title="Synthesis network"></a>Synthesis network</h3><blockquote><p>用于生成图像</p></blockquote><h4 id="删除传统输入"><a href="#删除传统输入" class="headerlink" title="删除传统输入"></a>删除传统输入</h4><p>利用 $512 \times 4 \times 4$ 的输入代替传统初始输入。</p><ul><li>避免初始输入值取值不当而生成不正常图片。</li><li>有助于减少特征纠缠</li></ul><h4 id="随机变化（添加噪声noise）"><a href="#随机变化（添加噪声noise）" class="headerlink" title="随机变化（添加噪声noise）"></a>随机变化（添加噪声noise）</h4><p>人们脸上有很多小特征，比如雀斑、发髻线的准确位置，这些都可以是随机的。将这些小特征插入GAN图像的常用方法是在输入向量中添加noise。</p><p>   为了控制噪声仅影响图片样式上细微的变化， StyleGAN 采用类似于 AdaIN 机制的方式添加噪声（噪声输入是由不相关的高斯噪声组成的单通道数据，它们被馈送到生成网络的每一层）。 即在 AdaIN 模块之前向每个通道添加一个缩放过的噪声，并稍微改变其操作的分辨率级别特征的视觉表达方式。 加入噪声后的生成人脸往往更加逼真与多样。</p><h4 id="自适应实例归一化（AdaIN）"><a href="#自适应实例归一化（AdaIN）" class="headerlink" title="自适应实例归一化（AdaIN）"></a>自适应实例归一化（AdaIN）</h4><script type="math/tex; mode=display">\operatorname{AdaIN}\left(x_i, y\right)=\sigma(y)\left(\frac{x_i-\mu\left(x_i\right)}{\sigma\left(x_i\right)}\right)+\mu(y)</script><p>   特征图的均值和方差中带有图像的风格信息。所以在这一层中，特征图减去自己的均值除以方差，去掉自己的风格。再乘上新风格的方差加上均值，以实现转换的目的。StyleGAN的风格不是由图像的得到的，而是w生成的。</p><h2 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h2><h3 id="样式混合（通过混合正则化）"><a href="#样式混合（通过混合正则化）" class="headerlink" title="样式混合（通过混合正则化）"></a>样式混合（通过混合正则化）</h3><blockquote><p>进一步明确风格控制（训练过程中使用）</p></blockquote><p>​    在训练过程中，stylegan采用混合正则化的手段，即在训练过程中使用两个latent code w （不是1个）。通过Mapping network输入两个latent code z，得到对应的w1和w2（代表两个风格），接下来为它们生成中间变量w’。然后利用第一个w1映射转换后来训练一些网络级别，用另一个w2来训练其余的级别，于是便能生成混合了A和B的样式特征的新人脸。</p><blockquote><p>低分辨率的style控制姿态、脸型、配件比如眼镜、发型等style，高分辨率的style控制肤色、头发颜色、背景色等style。</p></blockquote><h4 id="Truncation-Trick"><a href="#Truncation-Trick" class="headerlink" title="Truncation Trick"></a>Truncation Trick</h4><p>​    从数据分布来说，低概率密度的数据在网络中的表达能力很弱，直观理解就是，低概率密度的数据出现次数少，能影响网络梯度的机会也少，网络学习到其图像特征的能力就会减弱。</p><p>​    首先找到数据中的一个平均点，然后计算其他所有点到这个平均点的距离，对每个距离按照统一标准进行压缩，这样就能将数据点都聚拢了（<strong>相当于截断了中间向量𝑊′，迫使它保持接近“平均”的中间向量𝑊′ 𝑎𝑣𝑔</strong>），<strong>但是又不会改变点与点之间的距离关系。</strong></p><script type="math/tex; mode=display">\overline{\mathbf{w}}=\mathbb{E}_{\mathbf{z} \sim P(\mathbf{z})}[f(\mathbf{z})], \\\mathbf{w}^{\prime}=\overline{\mathbf{w}}+\psi(\mathbf{w}-\overline{\mathbf{w}}),\psi<1</script><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221203105020187.png" alt=""></p><h2 id="感知路径长度"><a href="#感知路径长度" class="headerlink" title="感知路径长度"></a>感知路径长度</h2><blockquote><p><em>Perceptual path length</em> ：测量在潜在空间中执行插值时图像的变化程度，来了解隐空间到图像特征之间的纠缠度。</p></blockquote><p> 图像生成其实是学习从一个分布到目标分布的迁移过程，如下图，已知input latent code 是 $z_1$，或者说白色的狗所表示的latent code是 $z_1$，目标图像是黑色的狗，黑狗图像的latent code 是 $z_2$。图中紫色的虚线是 $z_1$ 到 $z_2$ 最快的路径，绿色的曲线是我们不希望的路径。</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221125232548628.png" style="zoom: 80%;" /></p><p><strong><em>Perceptual path length 是一个指标，用于判断生成器是否选择了最近的路线（比如上图紫色虚线）</em></strong></p><script type="math/tex; mode=display">\begin{aligned}l_{\mathcal{W}}=\mathbb{E}\left[\frac { 1 } { \epsilon ^ { 2 } } d \left(g\left(\operatorname{lerp}\left(f\left(\mathbf{z}_1\right), f\left(\mathbf{z}_2\right) ; t\right)\right)\right.\right.\\\left.\left.g\left(\operatorname{lerp}\left(f\left(\mathbf{z}_1\right), f\left(\mathbf{z}_2\right) ; t+\epsilon\right)\right)\right)\right]\end{aligned}</script><script type="math/tex; mode=display">\begin{array}{r}l_{\mathcal{Z}}=\mathbb{E}\left[\frac { 1 } { \epsilon ^ { 2 } } d \left(G\left(\operatorname{slerp}\left(\mathbf{z}_1, \mathbf{z}_2 ; t\right)\right)\right.\right. \\\left.\left.G\left(\operatorname{slerp}\left(\mathbf{z}_1, \mathbf{z}_2 ; t+\epsilon\right)\right)\right)\right]\end{array}</script><blockquote><p>(1) 使用两个VGG16提取特征的加权差异来表示一对图像间的感知距离。<br>(2) 将潜在空间插值路径细分为线性段，每个段上的感知差异的总和就是感知路径长度。<br>(3)使用多份样本，分别计算z和w的PPL（感知距离长度）。由于z已经归一化，所以对z使用球面插值 slerp，而对w使用线性插值 lerp。评估为裁剪后仅包含面部的图像。</p></blockquote><h2 id="线性可分性"><a href="#线性可分性" class="headerlink" title="线性可分性"></a>线性可分性</h2><blockquote><p>训练特征，方便之后面部编辑，操纵图像特征，比如将男性图片变为女性</p></blockquote><p>如果隐空间与图像特征足够解耦，那么隐空间中存在线性超平面，可以二分类两种特征。在stylegan的文章中，基于CelebA-HQ数据集，训练40种特征的分类器。然后用生成器生成200000张图像，用训练的分类器分类，去掉置信度最低的一半，得到隐变量和标签已知的100000张图像。对每个属性，用线性SVM拟合预测z的类别，判断z是否足够线性。线性关系用X和Y的分布差异衡量。</p><p>结论：增加mapping network的深度确实有助于提高w的线性可分性。映射网络对传统生成器有同样的提升，具备通用性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pix2pix、CycleGAN</title>
      <link href="/2022/11/18/GAN04/"/>
      <url>/2022/11/18/GAN04/</url>
      
        <content type="html"><![CDATA[<h1 id="pix2pix"><a href="#pix2pix" class="headerlink" title="pix2pix"></a>pix2pix</h1><p>论文主页 <strong><em><a href="https://phillipi.github.io/pix2pix/">Image-to-Image Translation with Conditional Adversarial Networks</a></em></strong></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>pix2pix算法是解决对于图像域转换翻译问题的奠基地位的一个算法。其中有很多方面的应用（开篇的链接中已经展示实例）</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221118125851898.png" alt="效果展示"></p><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p>pix2pix算法实际上是在条件对抗网络(cGAN)上完善的，输入是一组<strong>图像对</strong>，如下图</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221118131553909.png" alt="pix2pix算法"></p><ul><li><p>转化域 $\boldsymbol X$ 、被转化域 $\boldsymbol Y$ :  $\boldsymbol x \in \boldsymbol X,\boldsymbol y \in \boldsymbol Y$ , 完成转换 $\boldsymbol X \rightarrow \boldsymbol Y$</p></li><li><p>生成器G : 根据输入的 $\boldsymbol x$ 生成虚假的图片 $G(\boldsymbol x)$</p></li><li>判别器D : 判别$G(\boldsymbol x)$和$\boldsymbol y$的真假</li></ul><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>我们的生成器的构架使用了U-net的</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221118144808656.png" alt="生成器结构"></p><p>如上图，左图是一般的图像的信息提取模型，即<strong>编码器-解码器</strong>的构架，pix2pix算法使用的是一个变种的编码器-解码器，即U-Net。 具体地说，我们在每个层i和层n-i之间添加跳过连接，其中n是层的总数。 每个跳过连接只是将第i层的所有信道与第n-i层的信道连接起来。</p><h3 id="判别器"><a href="#判别器" class="headerlink" title="判别器"></a>判别器</h3><p>判别器使用的是PatchGAN，事实上这个算法是根据局部识别来进行判别是否为真实的数据（将图片分成 $n \times n$ 份的小Patch作为输入），将所有的判别器的输出求其平均作为D的最终输出。</p><h3 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h3><p>目标函数可以沿用cGAN的目标函数</p><p>​    $\begin{aligned}<br>\mathcal{L}_{c G A N}(G, D)=&amp; \mathbb{E}_{x, y}[\log D(x, y)]+\mathbb{E}_{x, z}[\log (1-D(x, G(x, z))]<br>\end{aligned}$</p><p>不过这里论文中多加了一个L1范式作为强制降低低频部分的正确率，最终我们可以得到目标函数</p><script type="math/tex; mode=display">G^*=\arg \min _G \max _D \mathcal{L}_{c G A N}(G, D) + \lambda \mathcal{L}_{L 1}(G)</script><h1 id="CycleGAN"><a href="#CycleGAN" class="headerlink" title="CycleGAN"></a>CycleGAN</h1><p>论文主页  <strong><em><a href="https://junyanz.github.io/CycleGAN/">Unpaired Image-to-Image Translation using Cycle-Consistent Adversarial Networks</a></em></strong></p><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>CycleGAN是基于pix2pix的一个算法，解决了pix2pix数据集必须成对限制，降低了对数据集的要求；解决的问题依旧是图像风格转化已经视觉风格转化的问题。下图是文中的Cycle示例。</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221118152504582.png" alt="CycleGAN的示例"></p><h2 id="理论基础-1"><a href="#理论基础-1" class="headerlink" title="理论基础"></a>理论基础</h2><p>CycleGAN依然是解决图像转化的问题，其中这里不在需要成对的元数据来限制生成的图片，我们只需要两种不同风格的数据集（不需要成对匹配）即可。根据原始GAN的模型框架，在反方向叠加一个GAN构成CycleGAN如下图结构：</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221118155755782.png" alt="CycleGAN结构" style="zoom:67%;" /></p><p>我们只需要训练两个GAN模型如上图（中、右两部分）（$\hat x$、$\hat y$为生成器生成的数据）</p><ul><li>生成器$G$：$\hat y = G(x),x\in X$ ，表示讲$X$域的图像转到$Y$域的生成器；$ \hat y = G(\hat x)=G(F(y)),y \in Y$ 表示可以将 $F$ 生成的图片转换成生成前的图片</li><li>生成器$F$： $\hat x = F(\hat y) = F(G(x)),x \in X$ 表示可以将 $G$ 生成的图片转换成生成前的图片；$F(y) = \hat x,y \in Y$,表示讲$Y$域的图像转到$X$域的生成器</li><li>判别器$D_Y$：识别 $\hat y$ 是不是真实的$Y$域的图片</li><li>判别器$D_X$：识别$\hat x$ 是不是真实的$X$域的图片</li></ul><p>那么cycleGAN是如何控制好对于输入图片与输出图片的内容对应？上图中的有一个loss值为<code>cycle-consistency loss</code>，代表我们需要让上图中的$x$和$\hat x$ 以及 $y$和 $\hat y$ 的距离要尽可能小即最小化<code>cycle-consistency loss</code>这个值</p><blockquote><p>生成器和判别器的模型结构我们可以模仿pix2pix的模型结构，在需要改变的地方微调模型即可，这里不再赘述</p></blockquote><h3 id="目标函数-1"><a href="#目标函数-1" class="headerlink" title="目标函数"></a>目标函数</h3><script type="math/tex; mode=display">\begin{aligned}\mathcal{L}\left(G, F, D_X, D_Y\right) &=\mathcal{L}_{\mathrm{GAN}}\left(G, D_Y, X, Y\right)+\mathcal{L}_{\mathrm{GAN}}\left(F, D_X, Y, X\right) +\lambda \mathcal{L}_{\mathrm{cyc}}(G, F)\end{aligned}</script><ul><li><p>生成对抗损失</p><ul><li>$G: X \rightarrow Y $ 的部分</li></ul><p><strong>$\begin{aligned} \mathcal{L}_{\mathrm{GAN}}\left(G, D_Y, X, Y\right) &amp;=\mathbb{E}_{y \sim p_{\text {data }}(y)}\left[\log D_Y(y)\right]+\mathbb{E}_{x \sim p_{\text {data }}(x)}\left[\log \left(1-D_Y(G(x))\right]\right.\end{aligned}$ </strong></p><ul><li><p>$F:Y \rightarrow X$ 的部分</p><p>$\begin{aligned} \mathcal{L}_{\mathrm{GAN}}\left(F, D_X, Y, X\right) &amp;=\mathbb{E}_{x \sim p_{\text {data }}(x)}\left[\log D_X(x)\right]+\mathbb{E}_{y \sim p_{\text {data }}(y)}\left[\log \left(1-D_X(F(y))\right]\right.\end{aligned}$ </p></li></ul></li><li><p>循环一致损失 </p><p>$\begin{aligned} \mathcal{L}_{\text {cyc }}(G, F) &amp;=\mathbb{E}_{x \sim p_{\text {data }}(x)}\left[|F(G(x))-x|_1\right]+\mathbb{E}_{y \sim p_{\text {data }}(y)}\left[|G(F(y))-y|_1\right] \end{aligned}$</p></li></ul><h1 id="算法对比"><a href="#算法对比" class="headerlink" title="算法对比"></a>算法对比</h1><div class="table-container"><table><thead><tr><th></th><th>pix2pix</th><th>CycleGAN</th></tr></thead><tbody><tr><td>数据要求</td><td>成对组型数据</td><td>不用成对</td></tr><tr><td>目标函数</td><td><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221120151936786.png" alt="image-20221120151936786" style="zoom:67%;" /></td><td><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221120151859293.png" style="zoom:75%;" /></td></tr><tr><td>模型结构</td><td><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221118131553909.png" alt=""></td><td><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221120152009829.png" alt=""></td></tr><tr><td>方向</td><td>只能同时训练一个方向转换的模型</td><td>同时得到两个互转的模型</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> GAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WGAN</title>
      <link href="/2022/11/10/GAN03/"/>
      <url>/2022/11/10/GAN03/</url>
      
        <content type="html"><![CDATA[<h2 id="WGAN"><a href="#WGAN" class="headerlink" title="WGAN"></a>WGAN</h2><p>对于原始的GAN，目标函数涉及到了一个JS散度，这个在训练的时候会出现一个很麻烦的事情。我们首先来回顾一下我们在原始GAN中最终要优化的目标函数：</p><script type="math/tex; mode=display">\begin{aligned}C(G) &=\max _D V(G, D)=\mathbb{E}_{\boldsymbol{x} \sim p_{\text {data }}}\left[\log \frac{p_{\text {data }}(\boldsymbol{x})}{P_{\text {data }}(\boldsymbol{x})+p_g(\boldsymbol{x})}\right]+\mathbb{E}_{\boldsymbol{x} \sim p_g}\left[\log \frac{p_g(\boldsymbol{x})}{p_{\text {data }}(\boldsymbol{x})+p_g(\boldsymbol{x})}\right]\end{aligned}</script><p>再观察一下，当 $p_{data}$ 分布和 $p_g$ 分布，完全没有交集，或是说只有很狭窄的一个交际（在这高维空间中是很容易得到的情况），我们会和容易发现这个目标函数一个特点: <strong>目标函数是一个常数</strong> ！</p><blockquote><p>这一点非常重要，这不会体现在训练过程中的loss显示，对于两个毫无关系的分布，我们无法在训练的时候观察到模型学习后的分布是不是再向着我们需要的方向优化</p></blockquote><p>下图是论文对于两个分布所做出的JS散度值的一个图像</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221110111457723.png" alt="JSD分布" style="zoom: 80%;" /></p><h3 id="WGAN算法"><a href="#WGAN算法" class="headerlink" title="WGAN算法"></a>WGAN算法</h3><p>为了解决上述提出的问题，我们需要一个新的目标函数来优化这个训练的过程，为此这篇文章提出了一个Wasserstein距离来描述两个分布之间的距离，具体描述如下进行过解释：</p><p><img src="https://img-blog.csdnimg.cn/0b982572a8b84d3cb5c04a369c288d18.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56CB5Yac55S35a2p,size_20,color_FFFFFF,t_70,g_se,x_16" style="zoom: 67%;" /></p><p>最好的移动方案：</p><p><img src="https://img-blog.csdnimg.cn/8c9af577a8e64efd85403c2457751a52.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56CB5Yac55S35a2p,size_20,color_FFFFFF,t_70,g_se,x_16" style="zoom:67%;" /></p><p>我们把上述图示所展示的“推土机”距离的最好方案定义为Wasserstein距离，这样的话，无论两个分布距离有多么远，这个距离都是存在梯度的，可以用于优化更新。</p><p>新的问题来了，如何计算这个Wasserstein距离 ？我们直接给出公式（PS. 这个公式的推导我也不太会）</p><script type="math/tex; mode=display">\max _{D \in 1-\text { Lipschitz }}\left\{E_{x \sim P_{\text {data }}}[D(x)]-E_{x \sim P_G}[D(x)]\right\}</script><blockquote><p>注意到一个小细节, 对$D$有一个限制 $D \in 1-\text{Lipshitz}$ （或者 $D \in k-\text{Lipshitz}$ )，可视为 $D$ 为平滑的函数（不可以变化过于剧烈）；</p><p><strong>为什么要对 $D$ 进行平滑限制？ 如果不加 $D \in 1-\text{Lipshitz}$ 的限制，最后我们会看到这个Wasserstein距离会趋近于无穷大，无法收敛。</strong></p></blockquote><p> $D \in 1-\text{Lipshitz}$  的实现 ：对于这个限制实现，就是要求 $D$ 的变化率不可以很大，即再小范围内 $D$ 的变化不可以过于剧烈</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221110131625671.png" style="zoom:75%;" /></p>]]></content>
      
      
      
        <tags>
            
            <tag> GAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DCGAN、CGAN</title>
      <link href="/2022/11/09/GAN02/"/>
      <url>/2022/11/09/GAN02/</url>
      
        <content type="html"><![CDATA[<h2 id="DCGAN"><a href="#DCGAN" class="headerlink" title="DCGAN"></a>DCGAN</h2><h3 id="DCGAN-框架"><a href="#DCGAN-框架" class="headerlink" title="DCGAN 框架"></a>DCGAN 框架</h3><p>DCGAN实在原始GAN的基础上，对于生成器和判别器的模型结构进行了改进，采用可大量的深度卷积代替全连接层。从而提高了处理视觉问题方面上的质量和稳定性。</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221109162010501.png" alt="生成器部分结构图" style="zoom:50%;" /></p><p>在论文中给出了稳定DCGAN的方法：</p><ul><li>使用跨步卷积代替所有的CNN中的池化层（卷积—判别器、反卷积—生成器）</li><li>在生成器和判别器的隐藏层中使用<code>batchnorm</code> ,但是，最后的输出不可以使用（目的：训练更快、更稳定的）</li><li>移除所有的全连接层</li><li>生成器中的所有激活层都是用的是<code>Relu</code>函数，除了输出使用的是<code>Tanh</code>函数</li><li>判别器中的所有激活层都是使用<code>LeakyRelu</code> 函数</li></ul><h3 id="DCGAN-训练"><a href="#DCGAN-训练" class="headerlink" title="DCGAN 训练"></a>DCGAN 训练</h3><p>论文中的参数推荐</p><ul><li>所有模型均采用小批量随机梯度下降（SGD）训练，Batch_size大小为128。</li><li>所有权重均根据零中心正态分布进行初始化，标准偏差为0.02。</li><li>在LeakyReLU中，斜率均设置为0.2。</li><li>使用了Adam优化器并调整超参数。基础GAN中建议的学习率0.001太高了，改为使用0.0002。</li><li>将动量项β1保留在建议值0.9会导致训练振荡和不稳定性，而将其降低到0.5有助于稳定训练。 </li></ul><p><strong><em>评估无监督表示学习算法质量的一种常用技术是将其作为有监督数据集的特征提取器应用，并评估基于这些特征的线性模型的性能</em></strong></p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221109171011727.png" alt="DCGAN对比K-means和CNN的结果" style="zoom:70%;" /></p><p>使用GANS作为特征提取器对<strong>CIFAR-10</strong>进行分类<strong>（DCGAN不是在CIFAR-10上预训练的，而是在Imagenet-1k上训练的，这些特征用于对CIFAR-10图像进行分类 ）</strong>实验结果如上表所示</p><h2 id="CGAN"><a href="#CGAN" class="headerlink" title="CGAN"></a>CGAN</h2><p>CGAN可以视作将GAN重新拉回监督学习领域，我们使用原始GAN以及DCGAN训练时，只需要输入一个随机分布生成的噪音$z$ 即可，但是对于CGAN，不仅要输入一个噪音向量，还需要输入一个<code>label</code> 来控制生成的图片。</p><h3 id="CGAN-框架"><a href="#CGAN-框架" class="headerlink" title="CGAN 框架"></a>CGAN 框架</h3><ul><li>在生成器中，先验输入噪声 $P_z(z)$ 和 $\boldsymbol y$ 被组合成联合隐藏表示，对抗训练框架在如何组合该隐藏表示方面允许相当大的灵活性。</li><li>在判别器中，$\boldsymbol x$ 和 $\boldsymbol y$ 被表示为输入和判别器的一个识别参数</li></ul><script type="math/tex; mode=display">\min _G \max _D V(D, G)=\mathbb{E}_{\boldsymbol{x} \sim p_{\text {data }}(\boldsymbol{x})}[\log D(\boldsymbol{x} \mid \boldsymbol{y})]+\mathbb{E}_{\boldsymbol{z} \sim p_z(\boldsymbol{z})}[\log (1-D(G(\boldsymbol{z} \mid \boldsymbol{y})))]</script><p>我们可以看出，这个于原始GAN的区别为添加了一个前置条件 $\boldsymbol y$ 来控制生成图片的一个方向。</p><p>在结构中体现可以观察下图</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221110100927906.png" alt="CGAN结构" style="zoom:50%;" /></p><h3 id="CGAN-训练"><a href="#CGAN-训练" class="headerlink" title="CGAN 训练"></a>CGAN 训练</h3><p>论文是在MNIST图像上训练了一个条件对抗网，条件对抗网以它们的类标签为条件（相当于 $\boldsymbol y$），编码为单热向量（相当于 $\boldsymbol x$）。 </p><p>生成器和判别器的网络结构这里不在给出，因为现在有一些比论文中给出的结构更加成熟的运算层添加到D和G之中</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221110102014787.png" alt="生成图片的" style="zoom:50%;" /></p><p>上图为实验生成的样本展示（每一个对应一个类标签）</p>]]></content>
      
      
      
        <tags>
            
            <tag> GAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows终端优化</title>
      <link href="/2022/11/09/windows-config/"/>
      <url>/2022/11/09/windows-config/</url>
      
        <content type="html"><![CDATA[<h2 id="Terminal-Powershell优化"><a href="#Terminal-Powershell优化" class="headerlink" title="Terminal Powershell优化"></a>Terminal Powershell优化</h2><p>首先，展示优化后的结果，</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221109104312354.png" style="zoom:50%;" /></p><h3 id="下载-Windows-Terminal"><a href="#下载-Windows-Terminal" class="headerlink" title="下载 Windows Terminal"></a>下载 Windows Terminal</h3><p>从微软商店中搜索Windows Terminal，下载即可！</p><h3 id="打开配置文件"><a href="#打开配置文件" class="headerlink" title="打开配置文件"></a>打开配置文件</h3><p>打开Windows Terminal，点击下拉箭头符号，点击设置，出现如下图的界面</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221109104637563.png" alt="打开配置文件" style="zoom:50%;" /></p><p>选择打开配置json文件</p><h3 id="添加透明度配置"><a href="#添加透明度配置" class="headerlink" title="添加透明度配置"></a>添加透明度配置</h3><p>在json文件中找到<code>profiles</code>这一项中的<code>defaults</code> ,这一项中的所有配置为全局生效，而于<code>default</code>同级别的<code>list</code>中的每项为当前的配置文件中的子项目</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221109105224593.png" alt=""></p><p>对应了上面的每个终端的配置，为局部配置；一般来说配置的优先级为：局部配置 &gt; 全局配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;defaults&quot;</span><span class="punctuation">:</span> </span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;backgroundImage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\Projcets\\image\\bkg\\3-3.jpg&quot;</span><span class="punctuation">,</span> <span class="comment">//终端背景图片设置</span></span><br><span class="line">    <span class="attr">&quot;backgroundImageOpacity&quot;</span><span class="punctuation">:</span> <span class="number">0.40000000000000002</span><span class="punctuation">,</span> <span class="comment">// 图片的透明度设置（0-1）</span></span><br><span class="line">    <span class="attr">&quot;font&quot;</span><span class="punctuation">:</span> </span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;face&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JetBrainsMono Nerd Font Mono&quot;</span>  <span class="comment">// 字体设置，防止图标乱码，后面会说</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;opacity&quot;</span><span class="punctuation">:</span> <span class="number">40</span><span class="punctuation">,</span> <span class="comment">//透明度设置，越小越透明 （0-100 整数）</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>上面是，我对于我的json文件的配置</p><h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><ul><li>下载<code>oh-my-posh</code> : 在powershell中输入下面的安装命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winget install oh-my-posh</span><br></pre></td></tr></table></figure><blockquote><p>出现的问题：</p><ul><li>如果提示无法识别winget，说明电脑系统中没有安装winget，先要去微软商店中搜索winget后下载<img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221109110230464.png" style="zoom:33%;" />即可</li><li>如果出现冲突无法下载<code>oh-my-posh</code> ，安装提示给的oh-my-posh的ID使用命令<code>winget install --id xxxxx</code> 下载</li></ul></blockquote><p>下载完成后，默认的路径为<code>C:\Users\xxxx\AppData\Local\Programs\oh-my-posh</code> 下，可以查看所有的主题配置文件</p><ul><li>找到配置文件，powershell中输入<code>$Profile</code> 可以查看windows的配置文件，利用<code>code $Profile</code> 打开文件，并且添加如下的一段代码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">oh-my-posh init pwsh --config <span class="variable">$env</span>:POSH_THEMES_PATH\montys.omp.json | Invoke-Expression</span><br><span class="line">cls</span><br><span class="line"><span class="comment"># Shows navigable menu of all options when hitting Tab</span></span><br><span class="line">Set-PSReadlineKeyHandler -Key Tab -Function MenuComplete</span><br><span class="line"></span><br><span class="line"><span class="comment"># Autocompletion for arrow keys</span></span><br><span class="line">Set-PSReadlineKeyHandler -Key UpArrow -Function HistorySearchBackward</span><br><span class="line">Set-PSReadlineKeyHandler -Key DownArrow -Function HistorySearchForward</span><br><span class="line"></span><br><span class="line"><span class="comment"># auto suggestions</span></span><br><span class="line">Import-Module PSReadLine</span><br><span class="line">Set-PSReadLineOption -PredictionSource History</span><br></pre></td></tr></table></figure><p>第一行为主题的设置，其中<code>montys.omp.json</code>为主题配置文件，可以修改（可以通过上面的那个oh-my-posh的路径查看所有主题）</p><p>后面的几行都是针对于powershell的命令行提示提示补全的功能</p><blockquote><p>遇到的问题：</p><ul><li><code>$Profile</code>目录不存在，按照提示的路径新建即可，系统也会提示你新建这个文件</li><li>主题的图标出现乱码，使用Nerd字体，去网上下载Nerd字体，这里推荐 JetBrainsMono Nerd Font Mono 字体<strong>（一定要注意，设置字体时，一定要将配置文件中的list级下的所有局部配置的字体删掉，否则字体无法生效）</strong></li></ul></blockquote><p>最后附上：<strong><a href="https://www.nerdfonts.com/font-downloads">Nerd字体下载网站</a></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAN_start</title>
      <link href="/2022/10/31/GAN-start/"/>
      <url>/2022/10/31/GAN-start/</url>
      
        <content type="html"><![CDATA[<p><em>我们可以了解一下<a href="https://www.bilibili.com/video/BV19b4y127oZ/?spm_id_from=333.337.search-card.all.click&amp;vd_source=57e5130c3375ea877ab660ca10500f21">马尔可夫链</a>,但是在GAN中没有涉及到马尔科夫链，可以当作一个扩展来学习一下。</em></p><h2 id="GAN原理解析"><a href="#GAN原理解析" class="headerlink" title="GAN原理解析"></a>GAN原理解析</h2><h3 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h3><p>GAN译名生成对抗网络，强调为俩个网络（也可以是多个）互相对抗，共同进步最终达到一个稳态。</p><p><strong><em>Generative Adversarial Nets</em></strong> 中GAN可以看成两个模型的整合，即生成器G和判别器D。两者在文中关系被比作了造假者和警察，造假者制造假币，而警察识别假币；造假者可以根据警察的识别真币的能力更新出更难以识别的假币，而警察也可以根据造假者的造假能力强化自己的识别能力；最终，我们希望得到一个收敛的生成器G(D已经无法判别G生成的数据是真实数据还是生成数据)。</p><p>我们以图片生成为例，如下</p><ul><li>G是一个生成图片的网络，它接受一个随机的噪声z，通过这个噪声生成图片，记作G(z)</li><li>D是一个判别网络，判别一张图片是不是真实的。它的输入参数是x（代表一张图片），输出D(x)代表x为真实图片的概率，如果为1，就代表表100%是真实的图片，而输出为0，就代表不可能是真实的图片。</li></ul><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/gan_c.jpg" alt="GAN的原理图" style="zoom:50%;" /></p><p>以上为GAN在训练过程中的原理图，其中对于模型的目标函数的设计，<strong><em>Generative Adversarial Nets</em></strong> 给出了一个定量的函数，如下</p><script type="math/tex; mode=display">\min _G \max _D V(D, G)=\mathbb{E}_{\boldsymbol{x} \sim p_{\text {data }}(\boldsymbol{x})}[\log D(\boldsymbol{x})]+\mathbb{E}_{\boldsymbol{z} \sim p_{\boldsymbol{z}}(\boldsymbol{z})}[\log (1-D(G(\boldsymbol{z})))]</script><p>对于在训练时的更新，我们可以固定一个模型来更新另一个模型的参数，可以理解为如下情景</p><ul><li>更新G参数时，固定D更新目标函数</li></ul><script type="math/tex; mode=display">\min _G V(D,G) = \mathbb{E}_{\boldsymbol{z} \sim p_{\text {z }}(\boldsymbol{z})}[\log(1-D(G(\boldsymbol{z})))]</script><ul><li>更新D参数时，固定G更新目标函数   </li></ul><script type="math/tex; mode=display">\max _D V(D,G) = \mathbb{E}_{\boldsymbol{x} \sim p_{\text {data }}(\boldsymbol{x})}[\log(D(\boldsymbol x)] + \mathbb{E}_{\boldsymbol{\hat x} \sim p_g(\boldsymbol {\hat x})}[\log(1-D(\boldsymbol{\hat{x}}))]</script><blockquote><p>这里的 $\hat{x}$ 是 $z$ 空间在生成器 $G$ 上映射后的结果；<strong>对于 $p_g$ 是生成器 $G$ 将 $z$ 映射成  $\hat x$ 的后关于 $\hat  x$ 分布</strong>，即生成器 $G$ 所捕捉的分布。</p></blockquote><p>具体的训练算法如下：</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221108155146865.png" alt="训练算法" style="zoom:75%;" /></p><p>收敛图像化</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221110105451077.png" alt=""></p><h3 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h3><ul><li>固定住生成器 $G$ ，我们可以判别器 $D$ 最后一定收敛到如下公式<script type="math/tex; mode=display">D^* = \frac {p_{data}(\boldsymbol x)}{p_{data}(\boldsymbol x)+p_g(\boldsymbol x)}</script></li></ul><blockquote><p>得到最优判别器之后，我们可以将 $D^*$ 带入上述目标函数 得到一个新的目标函数 $C(G)$</p><script type="math/tex; mode=display">\begin{aligned}C(G) &=\max _D V(G, D) \\&=\mathbb{E}_{\boldsymbol{x} \sim p_{\text {data }}}\left[\log D_G^*(\boldsymbol{x})\right]+\mathbb{E}_{\boldsymbol{z} \sim p_{\boldsymbol{z}}}\left[\log \left(1-D_G^*(G(\boldsymbol{z}))\right)\right] \\&=\mathbb{E}_{\boldsymbol{x} \sim p_{\text {data }}}\left[\log D_G^*(\boldsymbol{x})\right]+\mathbb{E}_{\boldsymbol{x} \sim p_g}\left[\log \left(1-D_G^*(\boldsymbol{x})\right)\right] \\&=\mathbb{E}_{\boldsymbol{x} \sim p_{\text {data }}}\left[\log \frac{p_{\text {data }}(\boldsymbol{x})}{P_{\text {data }}(\boldsymbol{x})+p_g(\boldsymbol{x})}\right]+\mathbb{E}_{\boldsymbol{x} \sim p_g}\left[\log \frac{p_g(\boldsymbol{x})}{p_{\text {data }}(\boldsymbol{x})+p_g(\boldsymbol{x})}\right]\end{aligned}</script></blockquote><ul><li>当 $C(G)$ 的取最小值时，代表着 $p_{data}(\boldsymbol x) = p_g(\boldsymbol x)$ ,并且最小值恒定为 $-\log 4$</li></ul><blockquote><p>此部分证明用到了KL散度和JS散度，可以先去简单学习一下这部分</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> GAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-start</title>
      <link href="/2022/10/25/docker/"/>
      <url>/2022/10/25/docker/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几何图形</title>
      <link href="/2022/10/03/CG04/"/>
      <url>/2022/10/03/CG04/</url>
      
        <content type="html"><![CDATA[<h2 id="几何图形简介"><a href="#几何图形简介" class="headerlink" title="几何图形简介"></a>几何图形简介</h2><h3 id="几何图形的表示"><a href="#几何图形的表示" class="headerlink" title="几何图形的表示"></a>几何图形的表示</h3><h4 id="隐式函数表示"><a href="#隐式函数表示" class="headerlink" title="隐式函数表示"></a>隐式函数表示</h4><p>例如：$f(x,y,z) = x^2+y^2+z^2-1,f(x,y,z) = 0$ 都隐式的表示一个球面，但对于每一个$(x,y,z)$来说都是不直观的，但是对于每一个相对于球面的位置都可以很容易根据$f(x_1,y_1,z_1)$的值判断$(x_1,y_1,z_1)$在球面的内部还是外部</p><ul><li><p>优点：不直观</p></li><li><p>缺点：可以很容易的确定点与面的关系</p></li></ul><p>隐式函数的有点总结：</p><ul><li>描述起来比较简单</li><li>某些查询很容易(对象内部，到表面的距离)</li><li>适合于光线和表面的求交</li><li>对于简单的形状，精确描述/无采样误差</li><li>适合用来描述拓扑结构(如流体)</li></ul><h4 id="显示函数表示"><a href="#显示函数表示" class="headerlink" title="显示函数表示"></a>显示函数表示</h4><p>例如：$f(u,v) = ((2+\cos u)\cos v,(2+\cos u)\sin v,\sin u)$表示一个面。可以根据$(u,v)$很容易得到一个确认的$(x,y,z)$的点</p><ul><li>优点：可以很快的写出曲面上的任意一个点，直观</li><li>缺点：不好判断空间中的任意一点与面的关系</li></ul><h4 id="集合思想表示（CSG）"><a href="#集合思想表示（CSG）" class="headerlink" title="集合思想表示（CSG）"></a>集合思想表示（CSG）</h4><p>通过<strong>集合的布尔运算</strong>进行运算，如下图：</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221010152441764.png" alt="CSG集合运算1"></p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221010130154013.png" alt="CSG集合运算2"></p><p>通过对于简单的几何图形进行集合运算我们可以完成对于一些复杂几何模型的组合，相比于上面的隐式和显式的数学表达式来表示几何图形，更加立体直观。</p><h4 id="距离函数表示"><a href="#距离函数表示" class="headerlink" title="距离函数表示*"></a>距离函数表示*</h4><p>对于任何一个几何都不直接去描述它的表面，而去表述任何一个点到这个表面的最近距离。<strong>距离函数是指空间中任何一个点到需要表达的几何形体之间的最小距离。如果有一个点在几何形体的外面则距离是正数，如果有一个点在几何形体的里面则计算出最小距离后加一个负号。</strong>空间任何一个点都有一个距离值，把这两个物体各自的距离函数都算出来之后，把两个距离函数做一个融合，再把他恢复成原来的物体。</p><h4 id="分型表示※"><a href="#分型表示※" class="headerlink" title="分型表示※"></a>分型表示※</h4><p>分形类似于递归<br>例如雪花是六边形的，放大后每一条边上还有六边形，六边形里面仍然还有六边形。</p><h2 id="曲线和曲面"><a href="#曲线和曲面" class="headerlink" title="曲线和曲面"></a>曲线和曲面</h2><p>obj文件的组成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v:顶点信息</span><br><span class="line">vt:法向量信息</span><br><span class="line">vn:顶点向量信息</span><br><span class="line">f:面信息</span><br></pre></td></tr></table></figure><h3 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h3><h4 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h4><blockquote><p>贝塞尔曲线(Bezier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋，我们在绘图工具上看到的钢笔工具就是来做这种矢量曲线的。贝塞尔曲线是计算机图形学中相当重要的参数曲线，在一些比较成熟的位图软件中也有贝塞尔曲线工具，如PhotoShop等。</p></blockquote><p>贝塞尔曲线的一些特性：</p><ul><li>使用$n$个控制点${P_1,P_2,…,P_3}$来控制曲线的形状</li><li>曲线通过起始点$P_1$和终止点$P_n$，接近但不通过中间点$P_2 \sim  P_{n-1}$</li></ul><p>公式理解</p><p>step 1.在二维平面内选三个不同的点并依次用线段连接</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221010211725666.png" alt="step.1"></p><p>step 2.在线段$AB$和$BC$上找到$D、E$两点，使得$\frac{AD}{BD} = \frac{BE}{CE}$</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221010211952545.png" alt="step.2"></p><p>step 3.连接$DE$，并在$DE$上找到$F$点，使其满足$\frac{DF}{EF} =  \frac{AD}{BD} = \frac{BE}{CE}$</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221010212248041.png" alt="step.3"></p><p>step 4.找出符合上述条件的所有点</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/bse.gif" alt="step.4"></p><p>对于具体的公式以及对于相关的多阶的贝塞尔曲线的如下：</p><script type="math/tex; mode=display">B(t)=\sum_{i=0}^n\left(\begin{array}{l}n \\i\end{array}\right) P i(1-t)^{n-i} t^i=\left(\begin{array}{l}n \\0\end{array}\right) P 0(1-t)^n t^0+\left(\begin{array}{l}n \\1\end{array}\right) P 1(1-t)^{n-1} t^1+\ldots+\left(\begin{array}{c}n \\n-1\end{array}\right) P n-1(1-t)^1 t^{n-1}+\left(\begin{array}{l}n \\n\end{array}\right) P n(1-t)^0 t^n, t \in[0,1]</script><blockquote><p>类似于二项式展开的模式</p></blockquote><p>对于推导的过程，之后的文章中可以看到</p><div class="table-container"><table><thead><tr><th>曲线阶数</th><th>图示</th></tr></thead><tbody><tr><td>1阶</td><td><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/1j.gif" alt=""></td></tr><tr><td>3阶</td><td><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/2j.gif" alt=""></td></tr><tr><td>4阶</td><td><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/4j.gif" alt=""></td></tr><tr><td>5阶</td><td><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/5j.gif" style="zoom: 67%;" /></td></tr></tbody></table></div><h3 id="曲面"><a href="#曲面" class="headerlink" title="曲面"></a><strong>曲面</strong></h3><h4 id="贝塞尔曲面"><a href="#贝塞尔曲面" class="headerlink" title="贝塞尔曲面"></a>贝塞尔曲面</h4><p>其实在理解了贝塞尔曲线之后，贝塞尔曲面的原理也是十分容易理解的了，无非是一个从2维到3维的过渡。</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/bs.png" style="zoom:67%;" /></p><p>如果说对于曲线来说只有一个参数 $ t\in[0,1]$那么对于一个面来说，就应该有两个参数，分别设$u\in[0,1]，v\in[0,1]$，具体过程如下图所示:<br><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/gc.png" style="zoom:50%;" /></p><p>首先规定一共4x4 = 16个控制点，其水平面位置如图中16个黑点所示(并未表示出高度，防止图形太乱)，将这16个点分成4列，图中红色圈中的为一列的具体例子。</p><ul><li><p>第1步 在这4个控制点之下利用第一个参数$ u$ 运用计算贝塞尔曲线的方法得到蓝色点，因为有4列，所以一共可以得到如图所示的4个蓝色点。(灰色曲线分别为每列4个点所对应的贝塞尔曲线)</p></li><li><p>第2步 在得到4个蓝色顶点之后，在这四个蓝色顶点的基础之下利用第二个参数 $v$便可以成功得出贝塞尔曲面上的正确一点</p></li><li><p>第3步 遍历所有的 $u，v$ 值就可以成功得到一个贝塞尔曲面</p></li></ul><h2 id="几何处理"><a href="#几何处理" class="headerlink" title="几何处理"></a>几何处理</h2><h3 id="几何细分"><a href="#几何细分" class="headerlink" title="几何细分"></a>几何细分</h3><h4 id="Loop细分"><a href="#Loop细分" class="headerlink" title="Loop细分"></a>Loop细分</h4><p><em>需要三角形Mesh</em></p><p>步骤：</p><ol><li><p>create more triangles (vertices)</p><p>Split each triangle into four</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221010215430773.png" alt="三角形细分"></p></li><li><p><strong>tune their positions （形状需要有改变）</strong></p><p>Assign new vertex positions according to weights</p><p>New / old vertices updated differently 新老点分别改变</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221010215531593.png" alt="形状改变时权重计算" style="zoom: 80%;" /></p></li></ol><h4 id="Catmull-Clark-细分"><a href="#Catmull-Clark-细分" class="headerlink" title="Catmull-Clark 细分"></a>Catmull-Clark 细分</h4><p>通用Mesh</p><p>Non-quad face：非四边的面</p><p>Extraordinary vertex (奇异点)：指(degree != 4)的点</p><p>Each subdivision step:</p><ol><li>在每个面中添加顶点</li><li>在每条边上添加中点</li><li>连接所有新顶点</li></ol><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221010220044593.png" style="zoom:49%;" /><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221010220109312.png" alt="image-20221010220109312" style="zoom:49%;" /><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221010220200098.png" alt="image-20221010220200098" style="zoom:50%;" /></p><p>奇异点在第一次细分增加[非四边形面数量]，后续不变；所有非四边形面在第一次细分都会消失</p><p>Update Rules (Quad Mesh)：</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221010220234349.png" alt="更新的规则"></p><h3 id="几何简化"><a href="#几何简化" class="headerlink" title="几何简化"></a>几何简化</h3><p>目标：减少网格单元的数量，同时保持整体形状</p><p>应用：移动端、远距离（LOD）</p><p>几何的层次结构</p><p>边缘折叠：顶点合并</p><ul><li>哪些边合并？如何合并？<ul><li>Quadric Error Metrics（⼆次误差度量）放在二次误差之和最小的地方</li></ul></li></ul><p>通过二次误差进行简化</p><ul><li>以最小分数迭代折叠边缘</li><li>有问题，一条边的操作会影响其它边，需要更新<ul><li>数据结构：优先队列 or 堆</li></ul></li><li>贪心算法，非全局最优</li><li>可以有的放矢</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理以及边缘检测</title>
      <link href="/2022/10/03/openCV3/"/>
      <url>/2022/10/03/openCV3/</url>
      
        <content type="html"><![CDATA[<h2 id="图像梯度"><a href="#图像梯度" class="headerlink" title="图像梯度"></a>图像梯度</h2><p>★ 对于梯度的运算就是卷积的运算的过程 ★</p><h3 id="Sobel算子"><a href="#Sobel算子" class="headerlink" title="Sobel算子"></a>Sobel算子</h3><p>算子核矩阵如下：</p><script type="math/tex; mode=display">G_x = \begin{bmatrix}      -1 & 0 & 1 \\     -2 & 0 & 2 \\     -1 & 0 & 1     \end{bmatrix} * A    \qquad G_y = \begin{bmatrix}      -1 & -2 & -1 \\     0 & 0 & 0 \\     1 & 2 & 1     \end{bmatrix} * A</script><blockquote><p>注意这里并不是一成不变的，Sonbel核的大小会影响它对核值的改变</p></blockquote><ul><li>类似于高斯滤波，近的位置对于中心点影响大，远的位置影响小</li><li><p>上述可以看出，对于梯度变换黑到白的变换梯度为正，白到黑的变化梯度为负</p></li><li><p>代码演示</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sobelx = cv2.Sobel(img, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">3</span>)</span><br><span class="line">sobelx = cv2.convertScaleAbs(sobelx)   <span class="comment"># 这里因为在展示的时候，会把负数部分覆盖，于是我就要先取绝对值在展示</span></span><br><span class="line">sobely = cv2.Sobel(img, cv2.CV_64F, <span class="number">0</span>, <span class="number">1</span>, ksize=<span class="number">3</span>)</span><br><span class="line">sobely = cv2.convertScaleAbs(sobely)</span><br><span class="line">sobelxy1 = cv2.addWeighted(sobelx, <span class="number">0.5</span>, sobely, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line">sobelxy2 = cv2.Sobel(img, cv2.CV_64F, <span class="number">1</span>, <span class="number">1</span>, ksize=<span class="number">3</span>) <span class="comment"># 直接算x,y方向的卷积远没有分开之后算在相加的结果好，所以我们要避免直接计算</span></span><br><span class="line">sobelxy2 = cv2.convertScaleAbs(sobelxy2)</span><br></pre></td></tr></table></figure><h3 id="Scharr算子"><a href="#Scharr算子" class="headerlink" title="Scharr算子"></a>Scharr算子</h3><p>算子核矩阵如下：</p><script type="math/tex; mode=display">G_x = \begin{bmatrix}      -3 & 0 & 3 \\     -10 & 0 & 10 \\     -3 & 0 & 3     \end{bmatrix} * A     \qquad G_y = \begin{bmatrix}      -3 & -10 & -3 \\     0 & 0 & 0 \\     3 & 10 & 3     \end{bmatrix} * A</script><ul><li><p>代码展示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scharrx = cv2.Scharr(img, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">scharry = cv2.Scharr(img, cv2.CV_64F, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">scharrx = cv2.convertScaleAbs(scharrx)</span><br><span class="line">scharry = cv2.convertScaleAbs(scharry)</span><br><span class="line">scharrxy = cv2.addWeighted(scharrx, <span class="number">0.5</span>, scharry, <span class="number">0.5</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="Laplacian算子"><a href="#Laplacian算子" class="headerlink" title="Laplacian算子"></a>Laplacian算子</h3><p>算子核矩阵如下：</p><script type="math/tex; mode=display">G = \begin{bmatrix}      0 & 1 & 0 \\     1 & -4 & 1 \\     0 & 1 & 0     \end{bmatrix}</script><ul><li>代码展示</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">laplacian = cv2.Laplacian(img, cv2.CV_64F)</span><br><span class="line">laplacian = cv2.convertScaleAbs(laplacian)</span><br></pre></td></tr></table></figure><h3 id="算子对比"><a href="#算子对比" class="headerlink" title="算子对比"></a>算子对比</h3><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;../img/2.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">img = cv2.resize(img, (<span class="number">400</span>, <span class="number">400</span>))</span><br><span class="line"></span><br><span class="line">sobelx = cv2.Sobel(img, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">3</span>)</span><br><span class="line">sobely = cv2.Sobel(img, cv2.CV_64F, <span class="number">0</span>, <span class="number">1</span>, ksize=<span class="number">3</span>)</span><br><span class="line">sobelx = cv2.convertScaleAbs(sobelx)</span><br><span class="line">sobely = cv2.convertScaleAbs(sobely)</span><br><span class="line">sobelxy = cv2.addWeighted(sobelx, <span class="number">0.5</span>, sobely, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">scharrx = cv2.Scharr(img, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">scharry = cv2.Scharr(img, cv2.CV_64F, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">scharrx = cv2.convertScaleAbs(scharrx)</span><br><span class="line">scharry = cv2.convertScaleAbs(scharry)</span><br><span class="line">scharrxy = cv2.addWeighted(scharrx, <span class="number">0.5</span>, scharry, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">laplacian = cv2.Laplacian(img, cv2.CV_64F)</span><br><span class="line">laplacian = cv2.convertScaleAbs(laplacian)</span><br><span class="line"></span><br><span class="line">res = utils.figure_splicing((img, sobelxy, scharrxy, laplacian))</span><br><span class="line">utils.show_image(<span class="string">&#x27;res&#x27;</span>, res)</span><br></pre></td></tr></table></figure><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220927170847507.png" alt="三种算子的对比"></p><blockquote><p>第一个是原图，第二个是Sobel，第三个是Scharr，第四个是Laplacian</p></blockquote><h2 id="边缘检查"><a href="#边缘检查" class="headerlink" title="边缘检查"></a>边缘检查</h2><h3 id="Canny边缘检测"><a href="#Canny边缘检测" class="headerlink" title="Canny边缘检测"></a>Canny边缘检测</h3><ul><li>使用高斯滤波器，以平滑图像，滤除噪声（已解决）</li><li>计算图像中每个像素点的梯度强度和方向（已解决）</li><li>应用非极大值抑制，以消除边缘检测带来的杂算响应</li><li>应用双阈值检查来确定真实的和潜在的边缘</li><li>通过抑制孤立的弱边缘最终完成边缘检查</li></ul><h3 id="非极大值抑制"><a href="#非极大值抑制" class="headerlink" title="非极大值抑制"></a>非极大值抑制</h3><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221003172342119.png" alt="非极大值抑制线性插值法"></p><ul><li>线性插值：设$g_1$的梯度幅值为$M(g_1)$，设$g_2$的梯度幅值为$M(g_2)$，那么对于$dTmp_1$的亚像素的梯度复制为</li></ul><script type="math/tex; mode=display">M(dTmp_1) = wM(g_2)+(1-w)M(g_1)</script><p>​    其中$w = \frac {distance(dTmp_1,g2)}{distance(dTmp_1,g2)}$,$distance(x,y)$代表$x$到$y$的距离</p><ul><li>简化方法</li></ul><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221003173325878.png" alt="简化的线性插值的算法"></p><p>为了简化计算，由于一个像素周围共有8个像素，把一个像素的方向离散成八个方向，这样就只需要计算前后的即可，不应插值了</p><h3 id="双阈值检查"><a href="#双阈值检查" class="headerlink" title="双阈值检查"></a>双阈值检查</h3><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221003173938848.png" alt="双阈值检查图示"></p><ul><li>梯度值  &gt; <code>maxVal</code> : 处理为边界</li><li><code>minVal</code>&lt;梯度值&lt;<code>maxVal</code> : 连有边界的保留，否则舍弃</li><li>梯度值 &lt; <code>minVal</code> : 舍弃</li></ul><h3 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;../img/2.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">img = cv2.resize(img, (<span class="number">600</span>, <span class="number">400</span>))</span><br><span class="line">v1 = cv2.Canny(img, <span class="number">80</span>, <span class="number">150</span>)</span><br><span class="line">v2 = cv2.Canny(img, <span class="number">50</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">res = utils.figure_splicing((v1, v2))</span><br><span class="line">utils.show_image(<span class="string">&quot;11&quot;</span>, res)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20221003175922394.png" alt="最后运行结果的对比"></p><blockquote><p>对于阈值设置的大小我们可以发现这个，对于越大的的阈值范围（如图一）得到的细节越少杂讯点也少，而对于阈值范围越小的检测（如图二），得到的细节比较多但是同时加剧了得到杂质点的可能</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光栅化着色</title>
      <link href="/2022/09/27/CG03/"/>
      <url>/2022/09/27/CG03/</url>
      
        <content type="html"><![CDATA[<h2 id="Z-buffer"><a href="#Z-buffer" class="headerlink" title="Z-buffer"></a>Z-buffer</h2><p>画家算法：渲染由远到近，近处覆盖远处(对于多层三角形的互叠不可用)</p><p>一般不透明三角形深浅度表示，浅的盖住深的部分</p><p>深度缓存算法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(each triangle T)</span><br><span class="line">    for(each sample(x,y,z) in T)</span><br><span class="line">        if(z&lt;zbuffer[x,y])</span><br><span class="line">            framebuffer[x,y] =rgb</span><br><span class="line">            zbuffer[x,y]=z</span><br><span class="line">        else</span><br><span class="line">            ;</span><br></pre></td></tr></table></figure><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926172935937.png" alt="z-buffer算法图示" style="zoom:50%;" /></p><blockquote><p>$R$代表无限大，初始化z-buffer为全部元素为$R$</p></blockquote><h1 id="Shading"><a href="#Shading" class="headerlink" title="Shading"></a>Shading</h1><p>作用：<strong>引入颜色明暗的过程，在不同材质引入不同的影像</strong></p><h2 id="Blinn-Phong-Reflectance-Model"><a href="#Blinn-Phong-Reflectance-Model" class="headerlink" title="Blinn-Phong Reflectance Model"></a>Blinn-Phong Reflectance Model</h2><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926174617515.png" alt="三种光照情况" style="zoom:50%;" /></p><blockquote><p>Specular highlights： 高光部分</p><p>Diffuse reflection： 漫反射</p><p>Ambient lighting：环境光照</p></blockquote><p>计算光反射的部分：</p><blockquote><p>着色这里不考虑其他物体的存在</p></blockquote><ul><li><p>Inputs</p><ul><li>观测方向 $\mathbf{v}$</li><li>法线方向 $\mathbf{n}$</li><li>光照方向 $\mathbf{l}$</li><li>其他参数(颜色参数、光照强度参数等) 以及 shading point 的参数(材质等)</li></ul><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926175442610.png" alt="输入的方向向量" style="zoom:50%;" /></p></li></ul><blockquote><p>仅代表方向的向量均为单位向量</p></blockquote><h3 id="漫反射-diffuse-reflection"><a href="#漫反射-diffuse-reflection" class="headerlink" title="漫反射(diffuse reflection)"></a>漫反射(diffuse reflection)</h3><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926180227609.png" alt="单位面积得到的光的能量" style="zoom:50%;" /></p><blockquote><p>这里利用光源与法线方向的点积结果可以作为<strong>角度权重</strong></p></blockquote><p>根据能量守恒，我们可以假设光源发出的能量均匀的分布于以光源为圆心的圆壳上，那么对于随着光的传播，在球壳上的单位面积上的能量将会减小。</p><script type="math/tex; mode=display">P \propto \frac{I}{r^2}</script><blockquote><p>P代表单位球壳上的光强能量，r代表球半径，I代表总光强能量</p></blockquote><p>根据上面的推导，我们可以拿到总的公式，（注意，这个只是一个经验模型，并不是实际物理模型）</p><script type="math/tex; mode=display">L_d = k_d(I/r^2)max(0,\mathbf n \cdot \mathbf l)</script><blockquote><p>这里$L_d$漫反射的光强权重，$k_d,k_d \in [0,1]$ 表示材质对光强的吸收，$k_d$越大说明材质对于该光线的吸收度越小</p></blockquote><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926182316209.png" alt="漫反射的各个参数的影响" style="zoom:50%;" /></p><p>$k_d$ 的只是表示一个漫反射的参数，但是对于上述的模型可能会存在一定的整数倍的参数，导致不再满足$k_d \in [0,1]$ 这里还是那句话，这只是一个经验模型，没有经过物理实验严谨的实验； 对于上述的对比图也是证明了这个经验有一定的可信性</p><h3 id="高光项-specular-highlights"><a href="#高光项-specular-highlights" class="headerlink" title="高光项(specular highlights)"></a>高光项(specular highlights)</h3><p>引入一个半程向量用$\mathbf{h}$表示</p><script type="math/tex; mode=display">\mathbf h = bisector(\mathbf v , \mathbf l) = \frac {\mathbf v + \mathbf l} {|\mathbf v + \mathbf l|}</script><p>根据上一节漫反射的推到我们可以得到另一个经验模型参数：</p><script type="math/tex; mode=display">\begin{aligned}L_s &= k_s(I/r^2)max(0,\cos{α})^p\\    &= k_s(I/r^2)max(0,\mathbf n \cdot \mathbf h)^p\end{aligned}</script><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926184045259.png" alt="高光项图像解析" style="zoom: 50%;" /></p><ul><li><p>$\mathbf n$和$\mathbf h$ 的接近可以反映成<strong>观测方向和反射方向的相似性</strong></p></li><li><p>对于夹角上的p指数，是为了缩小对于高光项的角度范围，为了更好的模拟高光项，我们尽可能对于观察到高光项的角度进行所见，其中对于$\cos^p \alpha $ 对于p的变化可如下图所示</p></li></ul><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926191502758.png" alt="cos值随指数变化对比图" style="zoom:50%;" /></p><p>我们明显看出，对于随着p的增加，观测到高光的角度范畴逐渐减小。p对于可视图像的影响如下图</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926191807933.png" alt="参数对于结果的影响" style="zoom:50%;" /></p><h3 id="环境光照-Ambient-lighting"><a href="#环境光照-Ambient-lighting" class="headerlink" title="环境光照(Ambient lighting)"></a>环境光照(Ambient lighting)</h3><p>对于环境光照我们现在可以用一个常数进行表示</p><p>这里可以用  $ L_a = k_aI_a$来表示这个值 </p><blockquote><p>$k_a$为环境光照系数，$I_a$为环境光照强度</p></blockquote><p>通过上述的三个部分的介绍，我们可以将光照强度叠加得到我们最后的模型</p><script type="math/tex; mode=display">\begin{aligned}L &= L_a + L_d + L_s \\&=k_aI_a + k_d(I/r^2)max(0,\mathbf n \cdot \mathbf l) + k_s(I/r^2)max(0,\mathbf n \cdot \mathbf h)^p\end{aligned}</script><p>图像的叠加可以参考下面的一张图片</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926192937750.png" alt="三个部分的叠加的结果图" style="zoom:50%;" /></p><h2 id="Shading-Frequencies"><a href="#Shading-Frequencies" class="headerlink" title="Shading Frequencies"></a>Shading Frequencies</h2><p><strong>着色频率: 确定颜色渲染的点的位置</strong>，具体的变化如下图展示</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926193346177.png" alt="着色频率的实例" style="zoom:50%;" /></p><p>第一个，按每个四边形着色；第二个，按每个四边形的顶点进行着色；第三个，按每个像素进行着色，对应下面的三种着色方式：</p><ul><li>Flat Shading —— 频率按面(face)</li><li>Gouraud shading —— 频率按点(vertex)</li><li><strong>Phong shading</strong> (效果最好) ——频率按像素(pixel)</li></ul><p>三种方式的对比，如下图</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926194003145.png" alt="三种着色的方法对比" style="zoom:50%;" /></p><blockquote><p>补充：</p><ul><li>定义顶点的法线：①对于顶点关联的所有面求法向量在叠加平均 ②对于顶点关联的所有面求法向量根据每个面的面积求加权平均叠加</li><li>定义像素的法线：见之后的笔记</li></ul></blockquote><h2 id="Graphics-Real-time-Rendering-Pipeline"><a href="#Graphics-Real-time-Rendering-Pipeline" class="headerlink" title="Graphics(Real-time Rendering) Pipeline"></a>Graphics(Real-time Rendering) Pipeline</h2><p>图形渲染管线（实时渲染管线）</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926200247064.png" alt="图像渲染管线的步骤" style="zoom:67%;" /></p><h3 id="着色器-Shader-Programs"><a href="#着色器-Shader-Programs" class="headerlink" title="着色器(Shader Programs)"></a>着色器(Shader Programs)</h3><ul><li>vertex</li><li>fragment or pixel</li></ul><p>Example GLSL fragment shader program</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uniform sampler2D myTexture;</span><br><span class="line">uniform vec3 lightDir;</span><br><span class="line">uniform vec2 uv;   <span class="comment">// uv代表纹理位置轴</span></span><br><span class="line">varying vec3 norm;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">diffuseShader</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vec3 kd;</span><br><span class="line">    kd = <span class="built_in">texture2d</span>(myTexture,uv);</span><br><span class="line">    kd* = <span class="built_in">clamp</span>(<span class="built_in">dot</span>(-lightDir,norm),<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">    gl_FragColor = <span class="built_in">vec4</span>(kd,<span class="number">1.0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>着色器的编程不需要进行循环，只需对一个像素或者顶点的染色代码即可</p><p>推荐网站 <a href="http://shadertoy.com/view/ld3Gz2">Shadertoy </a> :  着色器的编写练习的网站</p><h1 id="Texture-Mapping"><a href="#Texture-Mapping" class="headerlink" title="Texture Mapping"></a>Texture Mapping</h1><p>纹理映射：不希望每个点都是一样的颜色，应该对于每一个点都要有自己的特定的属性</p><p>前提：3D（实体）的一个点一定可以对应到一个2D（纹理）上的一个点</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926210030928.png" alt="纹理效果渲染" style="zoom:50%;" /></p><h2 id="★-纹理插值"><a href="#★-纹理插值" class="headerlink" title="★ 纹理插值"></a>★ <strong>纹理插值</strong></h2><ul><li>重心坐标理解</li></ul><p>​    如何利用三角形三个顶点表示三角形内的任意一个点的坐标</p><p>​    假设三角形在▲ABC中，A、B、C的坐标已知，我们可以利用如下思想表示</p><script type="math/tex; mode=display">(x,y) = \alpha A + \beta B + \gamma C,\alpha + \beta + \gamma = 1，</script><p>​    便可以转化坐标：</p><script type="math/tex; mode=display">(x,y,z) \Rightarrow (\alpha,\beta,\gamma)</script><p>​    这种思想中若有条件$\alpha,\beta,\gamma \geq 0$时，表示的点必然在三角形内部或边缘</p><ul><li>使用中心坐标做纹理插值</li></ul><script type="math/tex; mode=display">V = \alpha V_a +\beta V_b + \gamma V_c</script><blockquote><p>其中$V_a,V_b,V_c$可以是位置、纹理信息、深度、色彩等</p><p>三维中的属性，在三维中做插值再把对应的属性投影到二维中</p></blockquote><h2 id="纹理应用"><a href="#纹理应用" class="headerlink" title="纹理应用"></a>纹理应用</h2><p>伪代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(u,v) = evaluate texture coordinate at(x,y)</span><br><span class="line">texcolor = texture.sample(u,v);</span><br><span class="line"><span class="built_in">set</span> sample<span class="number">&#x27;</span>s color to texcolor; <span class="comment">// 这里通常是上面所说的 漫反射常数kd</span></span><br></pre></td></tr></table></figure><blockquote><p>对于uv的理解，本文中设计比较少，可以通过<a href="https://baike.baidu.com/item/UV/2490475?fr=aladdin">百度词条</a>进行理解</p></blockquote><h3 id="双线性插值-Bilinear"><a href="#双线性插值-Bilinear" class="headerlink" title="双线性插值(Bilinear)"></a>双线性插值(Bilinear)</h3><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926214343739.png" alt="双线性插值" style="zoom:50%;" /></p><p>根据图示进行插值计算</p><ul><li>水平方向的插值</li></ul><script type="math/tex; mode=display">u_0 = lerp(s,u_{00} - u_{10}) \\u_1 = lerp(s,u_{10} - u_{11})</script><ul><li>垂直方向的插值</li></ul><script type="math/tex; mode=display">f(x,y) = lerp(t,u_0,u_1)</script><p>插值公式: $lerp(x,v_0,v_1) = v_0 + x(v_1 - v_0)$</p><h3 id="Bicubic插值"><a href="#Bicubic插值" class="headerlink" title="Bicubic插值"></a>Bicubic插值</h3><blockquote><p>课上没讲，我也没查</p></blockquote><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926215307575.png" alt="三种插值的方法对比" style="zoom:50%;" /></p><ul><li>Nearest ：不做插值，一个方格颜色是一样的</li><li>Bilinear ：双线性插值</li><li>Bicubic  ：三重多次插值</li></ul><h2 id="点查询-vs-范围查询"><a href="#点查询-vs-范围查询" class="headerlink" title="点查询 vs 范围查询"></a>点查询 vs 范围查询</h2><p>由于每个像素的范围的大小不同，这里就要用到范围查询</p><h3 id="Mipmap"><a href="#Mipmap" class="headerlink" title="Mipmap"></a>Mipmap</h3><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926222437539.png" alt="图像生成" style="zoom:50%;" /></p><p>这里的的存储量的计算方法计算就是对等比数列求和</p><script type="math/tex; mode=display">B = 1 + (\frac{1}{2})^1 +(\frac{1}{2})^2+ \ldots = \lim_{n \rightarrow \infty} \sum_{i=0}^n(\frac{1}{2})^i = \frac{4}{3}</script><h4 id="三线性插值"><a href="#三线性插值" class="headerlink" title="三线性插值"></a>三线性插值</h4><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926224725849.png" alt="三线性插值的过程" style="zoom:50%;" /></p><ul><li>先对D层进行双线性插值</li><li>在对高一D+1层进行双线性插值</li><li>最后对两次之间进行插值,得到D层插值数</li></ul><h4 id="Mipmap-Limitation"><a href="#Mipmap-Limitation" class="headerlink" title="Mipmap Limitation"></a>Mipmap Limitation</h4><p> <img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926225140502.png" alt="Mipmap的缺陷" style="zoom:50%;" /></p><p>远处的部分已经过度的模糊了</p><p>解决方法：<strong>各向异性过滤</strong> 或者 <strong>EWA过滤</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光栅化理论基础</title>
      <link href="/2022/09/26/CG02/"/>
      <url>/2022/09/26/CG02/</url>
      
        <content type="html"><![CDATA[<h2 id="Triangle"><a href="#Triangle" class="headerlink" title="Triangle"></a>Triangle</h2><ul><li>视锥——field-of-view(fovY)</li></ul><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926101213094.png" alt="视锥图示" style="zoom: 67%;" /></p><blockquote><p>如上图width上下中点所连线的的夹角，红色虚线部分的夹角</p></blockquote><p>根据上述理论，对于点的视锥是可只晓得，故只要了解到观测点距离屏幕的远近就可以设计出屏幕的高度height，如下图所示</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926101638079.png" alt="计算屏幕宽高" style="zoom:67%;" /></p><ul><li>屏幕——screen</li></ul><p>​    二维数组每个元素代表一个像素，坐标化(左下角(0,0))</p><p>​    每个像素的表示为$(x,y),x \in N,y\in N$，但是对于一个像素的中心点要了解是在$(x + 0.5,y+0.5)$处</p><ul><li>将转换的2D影像位置映射到屏幕上</li></ul><p>​    转换在坐标系中从$[-1,1]^3 \to  [0,width]\times[0,height]$，即这也称为<strong>视口变换</strong>，如下图</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926102855719.png" alt="视口变换" style="zoom:50%;" /></p><h3 id="Raster-Displays"><a href="#Raster-Displays" class="headerlink" title="Raster Displays"></a>Raster Displays</h3><ul><li>示波器（物理实验）主要的内容<a href="https://www.bilibili.com/video/BV1X7411F744/?p=5&amp;vd_source=57e5130c3375ea877ab660ca10500f21">GAME101</a>中</li><li>手机屏幕</li><li>电脑屏幕（LCD、VA）</li><li>电子墨屏幕</li></ul><blockquote><p>本部分我也不太清楚，读者可以自行百度</p></blockquote><h3 id="Triangle-Meshes"><a href="#Triangle-Meshes" class="headerlink" title="Triangle Meshes"></a>Triangle Meshes</h3><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926103827984.png" alt="三角形网络模拟实体" style="zoom:50%;" /></p><blockquote><p>三角形是可以利用网络链接来表示任何形状</p></blockquote><p>判断像素中心点与三角形点的关系</p><ul><li>采样函数(Sampling a Function)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">inside</span>(tri,x,y)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">tri 三角形 - 采样的信号</span></span><br><span class="line"><span class="comment">x,y 空间中坐标</span></span><br><span class="line"><span class="comment">return 1-(x,y) in tri ; 0-(x,y) not in tri ---在三角形的边上，不做处理</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>采样的过程</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>;x &lt; xmax; ++x)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>;x &lt; ymax; ++y)</span><br><span class="line">        image[x][y] = <span class="built_in">inside</span>(tri, x+<span class="number">0.5</span>, y+<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><ul><li>实现<code>inside(tri,x,y)</code> ：<strong>向量的叉乘</strong></li></ul><blockquote><p>对于一个三角型，有一个三角形包围盒，求解的方法也比较简单，取三角形，上下左右的最外部的坐标分别取对应的平行轴就可以求出包围盒</p></blockquote><h2 id="Aliasing"><a href="#Aliasing" class="headerlink" title="Aliasing"></a>Aliasing</h2><h3 id="Sample-Artifacts（走样）"><a href="#Sample-Artifacts（走样）" class="headerlink" title="Sample  Artifacts（走样）"></a>Sample  Artifacts（走样）</h3><ul><li>锯齿 ： 像素本身具有大小，并且颜色在像素中均匀分布</li></ul><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926111047666.png" alt="锯齿现象" style="zoom:50%;" /></p><ul><li>摩尔纹</li></ul><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926111018706.png" alt="摩尔纹现象" style="zoom:50%;" /></p><ul><li>Wagon Wheel Illusion (False Motion)</li></ul><p>……</p><blockquote><p>走样的本质就是，信号的变化太快，导致(采样函数)跟不上，导致走样</p></blockquote><h3 id="Antialiased-Sampling"><a href="#Antialiased-Sampling" class="headerlink" title="Antialiased Sampling"></a>Antialiased Sampling</h3><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926111626412.png" alt="Blurred Aliasing" style="zoom:50%;" /></p><blockquote><p>★在取样前我们先将采样信号进行滤波在进行采样</p></blockquote><h4 id="面转频"><a href="#面转频" class="headerlink" title="面转频"></a>面转频</h4><p>注意：<a href="https://www.bilibili.com/video/BV1X7411F744/?p=6&amp;spm_id_from=pageDriver&amp;vd_source=57e5130c3375ea877ab660ca10500f21">数学基础</a>视频的23分钟到27分钟</p><ul><li><p>高频信息：对于高频信息，多数是代表的是<strong>边界</strong>（颜色极具变换）的部分</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926112912112.png" alt="高通滤波" style="zoom:50%;" /></p></li><li><p>低频信息：图形内部比较稳定的部分</p></li></ul><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926113000063.png" alt="低通滤波" style="zoom:50%;" /></p><ul><li>中频某段的信息</li></ul><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926113134493.png" alt="某段的频率" style="zoom:50%;" /></p><h4 id="Convolution-卷积操作"><a href="#Convolution-卷积操作" class="headerlink" title="Convolution(卷积操作)"></a>Convolution(卷积操作)</h4><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926113400206.png" alt="卷积理论" style="zoom:33%;" /></p><blockquote><ul><li><p><strong>实域的卷积 = 频域的乘积</strong></p></li><li><p><strong>实域的乘积 = 频域的卷积</strong></p></li></ul></blockquote><h3 id="Sampling"><a href="#Sampling" class="headerlink" title="Sampling"></a>Sampling</h3><p>采样 = 重复频率的内容</p><p>走样 = 频率混叠</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926114026072.png" alt="走样的原理" style="zoom:50%;" /></p><p>反走样采样的解释</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926114151684.png" alt="反走样" style="zoom:50%;" /></p><blockquote><p>模糊的方法：低通滤波卷积</p></blockquote><h3 id="MSAA"><a href="#MSAA" class="headerlink" title="MSAA"></a>MSAA</h3><p>一个模糊化的三角形覆盖采样</p><p>内容：将一个像素考虑四个点，在包围盒中的像素观察每个像素这四个点对比采样信息函数的实用性赋予对应的像素的颜色权重</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926115144205.png" alt="MSAA图示" style="zoom: 50%;" /><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220926115218278.png" alt="权重赋予" style="zoom: 50%;" /></p><p>其他抗锯齿的方法：</p><ul><li>FXAA(Fast Approximate AA)</li><li><strong>TAA(Temporal AA) ★ </strong></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学基础</title>
      <link href="/2022/09/24/CG01/"/>
      <url>/2022/09/24/CG01/</url>
      
        <content type="html"><![CDATA[<h2 id="线性代数基础"><a href="#线性代数基础" class="headerlink" title="*线性代数基础"></a>*线性代数基础</h2><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><ul><li>用$\vec{a} 或者 \pmb{a}$表示向量，$\hat{a} = \frac{\vec{a}}{|\vec{a}|} $，表示单位向量<ul><li>向量的坐标形式，列向量$\vec{a} = \begin{pmatrix} x \ y \ z \end{pmatrix}$</li><li>$\pmb{a}^T = \begin{pmatrix} x &amp; y &amp; z \end{pmatrix} , 转置运算$</li></ul></li><li>向量的运算：<ul><li>$\vec{a} \cdot \vec{b} = |\vec{a}||\vec{b}|cos\theta，其中\theta为向量\vec{a},\vec{b}的夹角$</li><li>$\vec{a} \times  \vec{b} = -  \vec{b} \times \vec{a},|\vec{a} \times  \vec{b}| = |\vec{a}||\vec{b}|sin\theta$</li></ul></li></ul><blockquote><p>对于 $\vec{a} \times  \vec{b} $ 必然可以转换成矩阵和向量的乘积，相当对于向量的旋转即 $\pmb{a} \times \pmb{b} = C\pmb{b}$</p><p>对于$\pmb{a} = \begin{pmatrix} x_a \ y_a \ z_a  \end{pmatrix},\pmb{b} = \begin{pmatrix} x_b \ y_b \ z_b  \end{pmatrix} , \pmb{a} \times \pmb{b} = C\pmb{b} = \begin{pmatrix} 0 &amp; -z_a &amp; y_a \ z_a &amp; 0 &amp; -x_a\  -y_a &amp; x_a &amp; 0\end{pmatrix}\begin{pmatrix} x_b \ y_b \ z_b  \end{pmatrix} = \begin{pmatrix} y_az_b-y_bz_z \ z_ax_b-x_az_b \ x_ay_b-y_ax_b  \end{pmatrix}$</p></blockquote><ul><li>向量运算的应用：<ul><li>投影变换</li><li>向量相对位置的确定</li><li>点是否在图形内部的确定</li></ul></li></ul><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><ul><li>对于矩阵的定义不在给出（读者可以自行查询）</li><li>矩阵乘法：$M_{n\times m} * N_{m \times t} = A_{n \times t}$</li></ul><h2 id="★图像变换"><a href="#★图像变换" class="headerlink" title="★图像变换"></a>★图像变换</h2><p>主要的目的：3D World  $\rightarrow$ 2D Image</p><h3 id="2D的变换"><a href="#2D的变换" class="headerlink" title="2D的变换"></a>2D的变换</h3><h4 id="缩放反转"><a href="#缩放反转" class="headerlink" title="缩放反转"></a>缩放反转</h4><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/5.png" alt="缩放演示"></p><p>下面的公式便是代表了2D图像的缩放</p><script type="math/tex; mode=display">\left\{\begin{aligned} x' = S_xx\\   y' = S_yy\\\end{aligned}\right.</script><script type="math/tex; mode=display">\begin{pmatrix} x' \\ y' \end{pmatrix} = \begin{pmatrix} S_x & 0\\ 0 & S_y \end{pmatrix} \begin{pmatrix} x \\ y \end{pmatrix}</script><p>这个公式代表了对在x轴方式向上缩放$S_x$倍，对在y轴方式向上缩放$S_y$倍</p><blockquote><p>对于图像的反转，可以对$S_x = -1 或者 S_y = -1$操作方式与缩放完全一样</p></blockquote><h4 id="切变-shear"><a href="#切变-shear" class="headerlink" title="切变(shear)"></a>切变(shear)</h4><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220924102859076.png" alt="切变"></p><p>下面的公式代表了上方2D图像的切变</p><script type="math/tex; mode=display">\left\{\begin{aligned}x' = x + ay\\y' = y\end{aligned}\right.</script><script type="math/tex; mode=display">\begin{pmatrix}x'\\y'\end{pmatrix}=\begin{pmatrix}1 & a\\0 & 1\end{pmatrix}\begin{pmatrix}x\\y\end{pmatrix}</script><h4 id="旋转-Rotate"><a href="#旋转-Rotate" class="headerlink" title="旋转(Rotate)"></a>旋转(Rotate)</h4><blockquote><p>默认来说，都是关于原点(0,0)选择，不在原点旋转的可利用平移转化，并且默认为逆时针旋转</p></blockquote><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220924104631364.png" alt="旋转"></p><p><strong>旋转矩阵</strong>的结果，记住就可以了</p><script type="math/tex; mode=display">R_{\theta} = \begin{pmatrix}cos\theta & -sin\theta\\sin\theta & cos\theta\end{pmatrix}</script><h4 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h4><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220924105056731.png" alt="平移"></p><script type="math/tex; mode=display">\begin{equation}\begin{array}{l}x^{\prime}=x+t_x \\y^{\prime}=y+t_y\end{array}\end{equation}</script><p>但是对于平移出现了一个问题，无论如何变形，对于 上述的变形式子 无法变为$ \pmb{x’} = D\pmb{x}$的形式，这个问题会在下一节中展示</p><blockquote><p>对于$ \pmb{x’} = D\pmb{x}$形式的</p></blockquote><h3 id="齐次线性变换"><a href="#齐次线性变换" class="headerlink" title="齐次线性变换"></a>齐次线性变换</h3><p>为了更好的表示齐次线性表示所有的变换，为了不让平移变成一个特殊，我们在每个向量或者点添加一维元素如下表示：</p><ul><li>$ 2Dpoint = (x,y,1)^T $</li><li>$2D vector = (x,y,0)^T$</li></ul><p>这次可以利用以下公式对于<strong>线性变换</strong>表示平移：</p><script type="math/tex; mode=display">\left(\begin{array}{c}x^{\prime} \\y^{\prime} \\w^{\prime}\end{array}\right)=\left(\begin{array}{ccc}1 & 0 & t_x \\0 & 1 & t_y \\0 & 0 & 1\end{array}\right) \cdot\left(\begin{array}{l}x \\y \\1\end{array}\right)=\left(\begin{array}{c}x+t_x \\y+t_y \\1\end{array}\right)</script><p>对于前面说的缩放反转、切变、旋转都可以用扩展后的矩阵进行齐次变换只需要如下公式：</p><ul><li><p>缩放   $\mathbf{S}\left(s_x, s_y\right)=\left(\begin{array}{ccc}s_x &amp; 0 &amp; 0 \ 0 &amp; s_y &amp; 0 \ 0 &amp; 0 &amp; 1\end{array}\right)$</p></li><li><p>旋转 $\mathbf{R}(\alpha)=\left(\begin{array}{ccc}\cos \alpha &amp; -\sin \alpha &amp; 0 \ \sin \alpha &amp; \cos \alpha &amp; 0 \ 0 &amp; 0 &amp; 1\end{array}\right)$</p></li></ul><blockquote><p>注意：$\mathbf{R}(-\alpha)=\left(\begin{array}{ccc}\cos \alpha &amp; \sin \alpha &amp; 0 \ -\sin \alpha &amp; \cos \alpha &amp; 0 \ 0 &amp; 0 &amp; 1\end{array}\right) = \mathbf{R}(\alpha)^{-1} = \mathbf{R}(\alpha)^T$</p></blockquote><ul><li>平移 $\mathbf{T}\left(t_x, t_y\right)=\left(\begin{array}{ccc}1 &amp; 0 &amp; t_x \ 0 &amp; 1 &amp; t_y \ 0 &amp; 0 &amp; 1\end{array}\right)$</li></ul><blockquote><p>对于前两个，我们发现，仅仅用我们之前推导的$2\times2$的变换矩阵，替换这个$3\times3$的矩阵的左上方的$2\times2$的格子即可，对于平移我们只要在单位矩阵的第三列前两个元素添加平移的距离即可完成变换</p></blockquote><p>由于变换具有组合性，故对于一个变换都可以分解成多个基础齐次线性变换，所以对于一个变换矩阵M,都可以分解成上述的S、R、T的乘积，例如</p><script type="math/tex; mode=display">T_{(1,0)} \cdot R_{45}\left[\begin{array}{l}x \\ y \\ 1\end{array}\right]=\left[\begin{array}{lll}1 & 0 & 1 \\ 0 & 1 & 0 \\ 0 & 0 & 1\end{array}\right]\left[\begin{array}{ccc}\cos 45^{\circ} & -\sin 45^{\circ} & 0 \\ \sin 45^{\circ} & \cos 45^{\circ} & 0 \\ 0 & 0 & 1\end{array}\right]\left[\begin{array}{l}x \\ y \\ 1\end{array}\right]\\</script><blockquote><p> 代表先对图像逆时针旋转45°再平移(1,0)的距离</p></blockquote><p>此时我们可以知道$M = T_{(1,0)} \cdot R_{45},M代表整个过程的变换矩阵$</p><h4 id="非原点变换"><a href="#非原点变换" class="headerlink" title="非原点变换"></a>非原点变换</h4><p>一句话，平移至原点再变换。例如下图，</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220924121952208.png" alt="非原点变化的过程"></p><h3 id="3D的变换"><a href="#3D的变换" class="headerlink" title="3D的变换"></a>3D的变换</h3><p>类比于2D的变换，我们也可以类比2D齐次变换</p><ul><li>$ 3Dpoint = (x,y,z,1)^T $</li><li>$3D vector = (x,y,z,0)^T$</li></ul><p>对其线性变换如下公式：</p><script type="math/tex; mode=display">\left(\begin{array}{l}x^{\prime} \\y^{\prime} \\z^{\prime} \\1\end{array}\right)=\left(\begin{array}{lllc}a & b & c & t_x \\d & e & f & t_y \\g & h & i & t_z \\0 & 0 & 0 & 1\end{array}\right) \cdot\left(\begin{array}{l}x \\y \\z \\1\end{array}\right)</script><blockquote><p>对于这种扩展点的定义，我们也可以扩充至$\omega \neq 1，0$的情况，对于$(x,y,z,\omega),\omega \neq 0 代表真实点(x/\omega,y/\omega,z/\omega) $</p></blockquote><p>思考：对于应用上面的3D的齐次线性变换的变换矩阵，变换时是先平移还是先旋转（或者线性变化）呢 ？</p><font color="red"> *答：先进行线性变换，再平移*</font> <p>对于上面的相关的变换矩阵性质可以类比于2D变换的矩阵性质</p><h4 id="特殊的旋转矩阵"><a href="#特殊的旋转矩阵" class="headerlink" title="特殊的旋转矩阵"></a>特殊的旋转矩阵</h4><p>围绕x-、y-、z-轴旋转，如下矩阵：</p><script type="math/tex; mode=display">\begin{aligned}&\mathbf{R}_x(\alpha)=\left(\begin{array}{cccc}1 & 0 & 0 & 0 \\0 & \cos \alpha & -\sin \alpha & 0 \\0 & \sin \alpha & \cos \alpha & 0 \\0 & 0 & 0 & 1\end{array}\right) \\&\mathbf{R}_y(\alpha)=\left(\begin{array}{cccc}\cos \alpha & 0 & \sin \alpha & 0 \\0 & 1 & 0 & 0 \\-\sin \alpha & 0 & \cos \alpha & 0 \\0 & 0 & 0 & 1\end{array}\right) \\&\mathbf{R}_z(\alpha)=\left(\begin{array}{cccc}\cos \alpha & -\sin \alpha & 0 & 0 \\\sin \alpha & \cos \alpha & 0 & 0 \\0 & 0 & 1 & 0 \\0 & 0 & 0 & 1\end{array}\right)\end{aligned}</script><p>因此对于<strong>欧拉角</strong>我们可以这样转换为矩阵： $\mathbf{R}_{x y z}(\alpha, \beta, \gamma)=\mathbf{R}_x(\alpha) \mathbf{R}_y(\beta) \mathbf{R}_z(\gamma)$ 一般旋转</p><p>非欧拉角旋转矩阵求法</p><script type="math/tex; mode=display">\mathbf{R}(\mathbf{n}, \alpha)=\cos (\alpha) \mathbf{I}+(1-\cos (\alpha)) \mathbf{n} \mathbf{n}^T+\sin (\alpha) \underbrace{\left(\begin{array}{ccc}0 & -n_z & n_y \\n_z & 0 & -n_x \\-n_y & n_x & 0\end{array}\right)}_{\mathbf{N}}\\\mathbf{n}为旋转轴方向,\alpha为旋转角度</script><blockquote><p>默认旋转轴过原点</p></blockquote><h3 id="3D转换成2D"><a href="#3D转换成2D" class="headerlink" title="3D转换成2D"></a>3D转换成2D</h3><h4 id="view变换"><a href="#view变换" class="headerlink" title="view变换"></a>view变换</h4><ul><li>观测点位置（拍照位置）==== 默认（0，0，0）</li><li>观察方向（拍的方向）==== 默认  向-z的方向看</li><li>观察点旋转方向（相机旋转的方向）==== 默认 向上方向是y轴方向</li></ul><p>将一个一般观测点转化成上述默认方向</p><ul><li>先将位置平移到原点 </li></ul><script type="math/tex; mode=display">T_{\text {view }}=\left[\begin{array}{cccc}1 & 0 & 0 & -x_e \\ 0 & 1 & 0 & -y_e \\ 0 & 0 & 1 & -z_e \\ 0 & 0 & 0 & 1\end{array}\right]</script><ul><li>在旋转到默认方向</li></ul><script type="math/tex; mode=display">R_{\text {view }}=\left[\begin{array}{cccc}x_{\hat{g} \times \hat{t}} & y_{\hat{g} \times \hat{t}} & z_{\hat{g} \times \hat{t}} & 0 \\ x_t & y_t & z_t & 0 \\ x_{-g} & y_{-g} & z_{-g} & 0 \\ 0 & 0 & 0 & 1 \end{array}\right]</script><ul><li>变换矩阵$\mathbf{M} = R_{view} T_{view}$</li></ul><h4 id="Projection变换"><a href="#Projection变换" class="headerlink" title="Projection变换"></a>Projection变换</h4><p>3D转2D的关键步骤</p><h5 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h5><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220924160910708.png" alt="正交投影"></p><p>变换：直接去掉某一面的坐标元素量</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220924161115181.png" alt="规范的变换"></p><ul><li><p>我们定义一个长方体$[l,r]\times[b,t]\times[f,n]$</p></li><li><p>映射到坐标$[-1,1]^3$上，规范化，映射矩阵如下（先平移，再缩放）</p></li></ul><script type="math/tex; mode=display">M_{\text {ortho }}=\left[\begin{array}{cccc}\frac{2}{r-l} & 0 & 0 & 0 \\0 & \frac{2}{t-b} & 0 & 0 \\0 & 0 & \frac{2}{n-f} & 0 \\0 & 0 & 0 & 1\end{array}\right]\left[\begin{array}{cccc}1 & 0 & 0 & -\frac{r+l}{2} \\0 & 1 & 0 & -\frac{t+b}{2} \\0 & 0 & 1 & -\frac{n+f}{2} \\0 & 0 & 0 & 1\end{array}\right]</script><h5 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h5><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/tsty.jpg" alt="透视投影"></p><p>回顾：对于$(x,y,z,1)与(kx,ky,kz,k),k\ne0$表示为同一个点</p><p>透视投影完成的步骤：</p><ul><li>先收缩f处的画面(远近的间距不变、图像中心点不变)  $M^{(4\times4)}_{presp \rightarrow ortho}$</li><li><p>将收缩后的画面正交投影到n处 $M_{\text {ortho }}$ </p></li><li><p>透视变换矩阵 $M_{presp} = M_{ortho} \cdot M_{presp \rightarrow ortho}  $</p></li></ul><p>通过一定的推导我们可以求解到压缩变换矩阵 <a href="https://www.bilibili.com/video/BV1X7411F744/?p=4&amp;spm_id_from=pageDriver&amp;vd_source=57e5130c3375ea877ab660ca10500f21">推导过程</a></p><p>思考：对于远近平面挤压时，对于其z值挤压前后不变，那么除了f、n两处的面，其他的面挤压前后的z应该是怎样变换？（n~f之间的面） <a href="https://zhuanlan.zhihu.com/p/445801392">答案解析</a></p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220924163833203.png" alt="透视投影变化"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL(2)</title>
      <link href="/2022/09/20/OpenGL(2)/"/>
      <url>/2022/09/20/OpenGL(2)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在学习此节之前，建议将这三个单词先记下来：</p><ul><li>顶点数组对象：Vertex Array Object，VAO</li><li>顶点缓冲对象：Vertex Buffer Object，VBO</li><li>元素缓冲对象：Element Buffer Object，EBO 或 索引缓冲对象 Index Buffer Object，IBO</li></ul></blockquote><h2 id="绘制三角形"><a href="#绘制三角形" class="headerlink" title="绘制三角形"></a>绘制三角形</h2><p>在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。</p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滤波操作和过滤</title>
      <link href="/2022/09/19/OpenCV2/"/>
      <url>/2022/09/19/OpenCV2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章主要讲解了openCV对图像的平滑去噪的处理基础</p></blockquote><h2 id="滤波操作"><a href="#滤波操作" class="headerlink" title="滤波操作"></a>滤波操作</h2><p>卷积操作，通过像素卷积核对其核内的数值进行相关的数值变换操作</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220919162408220.png" alt="滤波卷积核展示"></p><p>这里是通过一定的<strong><em>规则</em></strong>，对于一组卷积核内的数值进行变换进行滤波</p><p>原始数据：<img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220919161920805.png" alt="初始数据图片"></p><blockquote><p>这张图片好像不是带杂音的图像，读者可以自己去找一找一张带杂讯的图片</p></blockquote><h3 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h3><p>openCV中可以使用<code>blur</code>函数对数据进行均值滤波</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blur = cv2.blur(img, (<span class="number">3</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><p><code>cv2.blur(image,kernel_size)</code>的两个参数<code>image</code>代表要处理的文件，<code>kernel_size</code>代表在滤波过程中使用的卷积核大小(最好使用奇数大小)</p><p>均值滤波实际上是对于卷积核内的数值相加再取<strong>算数均值</strong>填入卷积核最中间的格子中</p><h3 id="方框滤波"><a href="#方框滤波" class="headerlink" title="方框滤波"></a>方框滤波</h3><p>和均值率波的计算过程是一样的，不过可以添加<strong>正则化处理</strong>和大小越界</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box = cv2.boxFilter(img, -<span class="number">1</span>, (<span class="number">3</span>, <span class="number">3</span>), normalize=<span class="literal">True</span>) <span class="comment"># 第二个参数 为颜色通道统一，填入-1即可</span></span><br></pre></td></tr></table></figure><p>如果不加<code>normalize=True</code>或者设置<code>normalize=False</code>那么对于方框滤波就不会取均值而是取和，很容故意发生越界现象，比如下图：</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220919164253164.png" alt="不加正则化后的方框滤波处理"></p><h3 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h3><p>可理解为根据离卷积核中间的距离可以判断远近，通过高斯概率分布赋予对应方格权值，在进行计算<strong>加权均值</strong>填入卷积核中间的格子中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gaussian = cv2.GaussianBlur(img, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>最后的一个参数代表是正态分布的标准差为1</p></blockquote><h3 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h3><blockquote><p>对中间值取kernel中的值的中位数替换</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">median = cv2.medianBlur(img, <span class="number">5</span>)  <span class="comment">#第二个参数为kernel_size,这个5代表(5,5)</span></span><br></pre></td></tr></table></figure><h4 id="tip（图片拼接显示）"><a href="#tip（图片拼接显示）" class="headerlink" title="tip（图片拼接显示）"></a>tip（图片拼接显示）</h4><p>利用<code>np.hstack()</code>可以实现多组图像的水平拼接显示，而利用<code>np.vstack()</code>可以实现垂直拼接实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">figure_splicing</span>(<span class="params">images</span>):</span><br><span class="line">    res = np.hstack(images)<span class="comment"># res = np.vstack(images)</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = utils.figure_splicing((img, blur, gaussian, median))</span><br><span class="line">utils.show_image(<span class="string">&#x27;r&#x27;</span>, res)</span><br></pre></td></tr></table></figure><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220919171009056.png" alt="对比结果"></p><blockquote><p>四个图像依次是：原图、均值滤波、高斯滤波、中值滤波</p></blockquote><h2 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h2><h3 id="腐蚀操作"><a href="#腐蚀操作" class="headerlink" title="腐蚀操作"></a>腐蚀操作</h3><p>注意 ： <strong>腐蚀操作的对象通常是二值图</strong></p><p>类似与上面的滤波操作，腐蚀操作也有一个腐蚀核，对于一个腐蚀核，如果腐蚀核中有黑又白，那么将核中将白点全部涂黑，黑点不变（从图像开始检索，到检索玩这张图为一个迭代）</p><p>读入二值图像 利用<code>ret,dst=cv2.threshold(src,thresh,maxval,type)</code> (上一章有讲到)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;../img/fs.png&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这个项目没用的原因是因为图片本身就是二值图，不需要再根据函数得到二值图</p></blockquote><p>腐蚀操作的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), np.uint8)</span><br><span class="line">erosion = cv2.erode(img, kernel, iterations=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>对于腐蚀操作<code>cv2.erode()</code>的三个参数，第一个略过：</p><ul><li>第二个：kernel，腐蚀核的大小</li><li>第三个：iterations，迭代次数，迭代此时对于结果影像如下图</li></ul><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220919173712644.png" alt="迭代次数对于结果的影响"></p><p>对应的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">erosion1 = cv2.erode(img, kernel, iterations=<span class="number">1</span>)</span><br><span class="line">erosion2 = cv2.erode(img, kernel, iterations=<span class="number">2</span>)</span><br><span class="line">erosion3 = cv2.erode(img, kernel, iterations=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">res = utils.figure_splicing((img, erosion1, erosion2, erosion3))</span><br><span class="line">utils.show_image(<span class="string">&quot;对比&quot;</span>, res)</span><br></pre></td></tr></table></figure><blockquote><p>上述四图依次是原图、迭代1次、迭代2次、迭代3次的结果 ，其中kernel 保持为（5，5）</p><p>腐蚀核大小对于结果的影响这里就不在给出，读者若有兴趣可以自行尝试，或者取我的GitHub上查看源码</p></blockquote><h3 id="膨胀操作"><a href="#膨胀操作" class="headerlink" title="膨胀操作"></a>膨胀操作</h3><p>膨胀操作是腐蚀操作的逆操作，膨胀核中只要存在白点就要将核中黑点染白，其他于腐蚀操作类似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), np.uint8)</span><br><span class="line">dilate = cv2.dilate(img, kernel, iterations=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>膨胀操作的基本代码，参数于腐蚀操作的参数一样这里就不再介绍</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">j0 = img = cv2.imread(<span class="string">&#x27;../img/fs.png&#x27;</span>)</span><br><span class="line">kernel1 = np.ones((<span class="number">3</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line">j1 = cv2.erode(j0, kernel1, iterations=<span class="number">10</span>)</span><br><span class="line">j2 = cv2.dilate(j1, kernel1, iterations=<span class="number">10</span>)</span><br><span class="line">res2 = utils.figure_splicing((j0, j1, j2))</span><br><span class="line">utils.show_image(<span class="string">&quot;process&quot;</span>, res2)</span><br></pre></td></tr></table></figure><p>上面的代码这是腐蚀与膨胀的结合产生的结果的代码，下图是最终呈现的效果</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220919183610396.png" alt="开运算"></p><h3 id="开运算和闭运算"><a href="#开运算和闭运算" class="headerlink" title="开运算和闭运算"></a>开运算和闭运算</h3><ul><li>开运算：先腐蚀，再膨胀（结果见上一节的图像）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">j0 = img = cv2.imread(<span class="string">&#x27;../img/fs.png&#x27;</span>)</span><br><span class="line">kernel1 = np.ones((<span class="number">3</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line">j1 = cv2.erode(j0, kernel1, iterations=<span class="number">10</span>)</span><br><span class="line">j2 = cv2.dilate(j1, kernel1, iterations=<span class="number">10</span>)</span><br><span class="line">res2 = utils.figure_splicing((j0, j1, j2))</span><br><span class="line">utils.show_image(<span class="string">&quot;process&quot;</span>, res2)</span><br></pre></td></tr></table></figure><ul><li>闭运算：先膨胀，再腐蚀</li></ul><p>结果如下：<img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220919185435402.png" alt="闭运算"></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kernel2 = np.ones((<span class="number">3</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line">ji1 = cv2.dilate(j0, kernel2, iterations=<span class="number">10</span>)</span><br><span class="line">ji2 = cv2.erode(ji1, kernel2, iterations=<span class="number">10</span>)</span><br><span class="line">res3 = utils.figure_splicing((j0, ji1, ji2))</span><br><span class="line">utils.show_image(<span class="string">&quot;process&quot;</span>, res3)</span><br></pre></td></tr></table></figure><h3 id="梯度计算"><a href="#梯度计算" class="headerlink" title="梯度计算"></a>梯度计算</h3><p>梯度 = 膨胀 - 腐蚀</p><p>代码描述</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradient = cv2.morphologyEx(pie, cv2.MORPH_GRADIENT, kernel)</span><br></pre></td></tr></table></figure><ul><li>pie : 传入图片</li><li>第二个参数为计算模式，这里是计算梯度</li><li>传入的核大小</li></ul><blockquote><p>我们注意这个函数是对于操作模式的封装其原因为<code>cv2.morphologyEx(src, op, kernel)</code>,作用是对于多种形态学的运算，三个参数分别是</p><ul><li>src传入的图片</li><li>op进行变化的方式</li><li>kernel表示方框的大小</li></ul><p>op = cv2.MORPH_OPEN 进行开运算，指的是先进行腐蚀操作，再进行膨胀操作</p><p>op = cv2.MORPH_CLOSE 进行闭运算， 指的是先进行膨胀操作，再进行腐蚀操作</p><p>op的值可以点击<a href="https://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/opening_closing_hats/opening_closing_hats.html">这里</a>了解更多</p></blockquote><h3 id="礼帽和黑帽"><a href="#礼帽和黑帽" class="headerlink" title="礼帽和黑帽"></a>礼帽和黑帽</h3><ul><li>礼帽=原始输入 - 开运算结果</li><li>黑帽=闭运算结果 - 原始输入</li></ul><p>对应<code>cv2.morphologyEx(src, op, kernel)</code>中的op值分别是：</p><ul><li>礼帽<code>op = cv2.MORPH_TOPHAT</code></li><li>黑帽<code>op= cv2.MORPH_BLACKHAT</code></li></ul><p>对于上述描述的形态学参数的计算我放在了一段代码中，如下段代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pie = cv2.imread(<span class="string">&#x27;../img/fs.png&#x27;</span>)</span><br><span class="line">pie = cv2.resize(pie, (<span class="number">200</span>, <span class="number">200</span>))</span><br><span class="line">kernel = np.ones((<span class="number">7</span>, <span class="number">7</span>), np.uint8)</span><br><span class="line"></span><br><span class="line">openNum = cv2.morphologyEx(pie, cv2.MORPH_OPEN, kernel)  <span class="comment"># 开运算</span></span><br><span class="line">closeNum = cv2.morphologyEx(pie, cv2.MORPH_CLOSE, kernel)  <span class="comment"># 闭运算</span></span><br><span class="line">gradient = cv2.morphologyEx(pie, cv2.MORPH_GRADIENT, kernel)  <span class="comment"># 梯度</span></span><br><span class="line">top = cv2.morphologyEx(pie, cv2.MORPH_TOPHAT, kernel)  <span class="comment"># 礼帽</span></span><br><span class="line">black = cv2.morphologyEx(pie, cv2.MORPH_BLACKHAT, kernel)  <span class="comment"># 黑帽</span></span><br><span class="line"></span><br><span class="line">res = utils.figure_splicing((pie, openNum, closeNum, gradient, top, black))</span><br><span class="line">utils.show_image(<span class="string">&#x27;images result&#x27;</span>, res)</span><br></pre></td></tr></table></figure></p><p>其运算的结果如下：</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220919193723637.png" alt="结果对比"></p><blockquote><p>五张图片依次是，原图、开运算结果、闭云算、梯度、礼帽、黑帽</p></blockquote><p>本篇文章中的代码我已经传入我的<a href="https://github.com/Mircela/LearnOpenCV.git">Github</a> ,若想查看代码请移步至我的GitHub</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex入门</title>
      <link href="/2022/09/18/Latex/"/>
      <url>/2022/09/18/Latex/</url>
      
        <content type="html"><![CDATA[<h3 id="latex的vscode配置"><a href="#latex的vscode配置" class="headerlink" title="latex的vscode配置"></a>latex的vscode配置</h3><ul><li>下载latex镜像文件，下载地址点击<a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/">这里</a>可以进入</li></ul><p>​    这里我下载的是下面的这一个</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220919124920806.png" style="zoom:90%;" /></p><blockquote><p>对于这种.iso文件直接利用win10自带的虚拟光驱打开即可，不需要再额外下载其他虚拟光驱软件</p></blockquote><ul><li>配置vscode setting文件</li></ul><script type="math/tex; mode=display">打开vscode 左下角设置\rightarrow右上角打开设置(json)\rightarrow将下列代码粘贴至json文件中</script><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;latex-workshop.latex.autoBuild.run&quot;</span><span class="punctuation">:</span> <span class="string">&quot;never&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.showContextMenu&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.intellisense.package.enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.message.error.show&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.message.warning.show&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latexmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latexmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-pdf&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-outdir=%OUTDIR%&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.recipes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;XeLaTeX&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PDFLaTeX&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;pdflatex&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BibTeX&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;bibtex&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LaTeXmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;latexmk&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex -&gt; bibtex -&gt; xelatex*2&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex -&gt; bibtex -&gt; pdflatex*2&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;pdflatex&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.clean.fileTypes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;*.aux&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.bbl&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.blg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.idx&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.ind&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.lof&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.lot&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.out&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.toc&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.acn&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.acr&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.alg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.glg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.glo&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.gls&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.ist&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.fls&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.log&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.fdb_latexmk&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.autoClean.run&quot;</span><span class="punctuation">:</span> <span class="string">&quot;onFailed&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.recipe.default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lastUsed&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.internal.synctex.keybinding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;double-click&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.viewer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tab&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.external.viewer.command&quot;</span><span class="punctuation">:</span></span><br><span class="line"><span class="string">&quot;D:/Tool/SumatraPDF/SumatraPDF.exe&quot;</span><span class="punctuation">,</span>  <span class="comment">//注意修改路径</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.external.viewer.args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;%PDF%&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.external.synctex.command&quot;</span><span class="punctuation">:</span></span><br><span class="line"><span class="string">&quot;D:/Tool/SumatraPDF/SumatraPDF.exe&quot;</span><span class="punctuation">,</span>  <span class="comment">//注意修改路径</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.external.synctex.args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;-forward-search&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;%TEX%&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;%LINE%&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;%PDF%&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><blockquote><p>直接复制到vscode的setting.json的大括号之中（注意修改配置的路径）、</p></blockquote><h3 id="latex语法"><a href="#latex语法" class="headerlink" title="latex语法"></a>latex语法</h3><p>由于latex语法比较多且有点乱(本人学的也不太明白)，</p><p>我们可以通过<a href="https://github.com/CTeX-org/lshort-zh-cn">这里</a>找到latex手册进行学习</p><p>一些简单的常用的语法建议看一下这个<a href="https://www.bilibili.com/video/BV11h41127FD?from=search&amp;seid=12274189218691696421&amp;spm_id_from=333.337.0.0&amp;vd_source=57e5130c3375ea877ab660ca10500f21">视频</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openGLVscode配置</title>
      <link href="/2022/09/17/openGL-config/"/>
      <url>/2022/09/17/openGL-config/</url>
      
        <content type="html"><![CDATA[<h2 id="参考步骤"><a href="#参考步骤" class="headerlink" title="参考步骤"></a>参考步骤</h2><ul><li>windows 需安装 MinGW, install gcc、g++、gdb 和 mingw32-make 并 进入到 <code>MinGW\bin</code> 文件夹下 把 mingw32-make.exe 修改成 make.exe</li></ul><blockquote><p><a href="https://sourceforge.net/projects/mingw/">MinGW</a> 不要下载 <em>MinGW-w64</em>因为后面可能会出现问题 MinGW，即 Minimalist GNU For Windows。它是一些头文件和端口库的集合，该集合允许人们在没有第三方动态链接库的情况下使用 GCC 产生 Win32 程序。</p></blockquote><ul><li><p>vscode 插件 <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools"><code>C/C++</code></a>、<a href="https://marketplace.visualstudio.com/items?itemName=danielpinto8zz6.c-cpp-project-generator"><code>C/C++ Project Generator</code></a></p></li><li><p>glfw 下载 <a href="https://www.glfw.org/download.html"><code>Windows pre-compiled binaries</code></a></p></li></ul><blockquote><p>选择<strong>Windows pre-compiled binaries</strong>，因为我们使用的 MinGW 所以选择 <a href="https://github.com/glfw/glfw/releases/download/3.3.4/glfw-3.3.4.bin.WIN32.zip">32-bit Windows binaries</a> </p></blockquote><ul><li>glad <a href="https://glad.dav1d.de/">在线服务</a> 生成静态库</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc ./src/glad.c -c -I ./include/ // 生成 .o文件</span><br><span class="line">&gt; ar -rc libglad.a glad.o           // 生成我们所需要的 .a文件</span><br></pre></td></tr></table></figure><blockquote><p>将生成的 libglad.a 复制到 lib 文件下</p></blockquote><ul><li>glm 复制到 include 目录下</li><li>imgui 复制到 include 目下,Makefile 中添加以下命令</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># define the C source files</span></span><br><span class="line">SOURCES:= <span class="variable">$(<span class="built_in">wildcard</span> $(<span class="built_in">patsubst</span> %,%/*.cpp, <span class="variable">$(SOURCEDIRS)</span>)</span>)</span><br><span class="line">SOURCES+= <span class="keyword">include</span>/imgui/imgui_impl_glfw.cpp <span class="keyword">include</span>/imgui/imgui_impl_opengl3.cpp</span><br><span class="line">SOURCES+= <span class="keyword">include</span>/imgui/imgui.cpp <span class="keyword">include</span>/imgui/imgui_demo.cpp <span class="keyword">include</span>/imgui/imgui_draw.cpp <span class="keyword">include</span>/imgui/imgui_widgets.cpp</span><br></pre></td></tr></table></figure><ul><li><p>assimp 下载已编译好的文件 <a href="https://www.mediafire.com/file/jjiv41rv8euy3dt/Assimp3-1-1_MinGW4-8-1_Win32.zip/file">Assimp3-1-1_MinGW4-8-1_Win32.zip</a></p></li><li><p><a href="https://github.com/yocover/start-learning-opengl/blob/main/Makefile">参考 Makefile 文件</a></p></li></ul><h2 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h2><h3 id="1-Run-和-Clean"><a href="#1-Run-和-Clean" class="headerlink" title="1. Run 和 Clean"></a>1. Run 和 Clean</h3><p><strong>测试代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glfwInit</span>();</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">processInput</span>(window);</span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"><span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line"><span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行命令 run 编译和运行.exe 程序</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make run <span class="built_in">dir</span>=<span class="number">01</span>_test_glfw</span><br></pre></td></tr></table></figure><p><strong>执行命令 clean 删除 .exe 和对应文件夹下的.o 文件</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean <span class="built_in">dir</span>=<span class="number">01</span>_test_glfw</span><br></pre></td></tr></table></figure><h3 id="2-Debug"><a href="#2-Debug" class="headerlink" title="2. Debug"></a>2. Debug</h3><p>需要设置调试一个文件 修改 <code>tasks.json</code>下面的条目</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;windows&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;powershell&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">         <span class="string">&quot;-c&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="string">&quot;make dir=01_test_glfw&quot;</span><span class="punctuation">,</span> <span class="comment">// 调式 01_test_glfw/main.cpp</span></span><br><span class="line">     <span class="punctuation">]</span></span><br><span class="line"> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>​    主要参考视频：<a href="https://www.bilibili.com/video/BV1BX4y1g7R6?vd_source=57e5130c3375ea877ab660ca10500f21">VsCode下配置OpenGL开发环境</a></p><p>​    文字参考：<a href="https://github.com/yocover/start-learning-opengl">VsCode下配置OpenGL开发环境GitHub</a></p><blockquote><p>若按照上面视频出现包路径找不到，可以把对应的.a以及.h文件直接复制到MinGW路径下对应lib文件夹和include文件夹</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像读入以及读入模式</title>
      <link href="/2022/09/16/OpenCV1/"/>
      <url>/2022/09/16/OpenCV1/</url>
      
        <content type="html"><![CDATA[<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python==xx.xx</span><br><span class="line">pip insatll opencv-contrib-python==xx.xx</span><br></pre></td></tr></table></figure><blockquote><p>注意两个包的版本号要相同</p></blockquote><h3 id="读取图片"><a href="#读取图片" class="headerlink" title="读取图片"></a>读取图片</h3><blockquote><p>opencv读入的图片默认是RBG格式的，若要用matplotlib画图需要转成RGB格式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">r&#x27;./img/2.jpg&#x27;</span>) <span class="comment"># 读入图片</span></span><br><span class="line"><span class="built_in">type</span>(img)</span><br><span class="line"><span class="comment"># &lt;class &#x27;numpy.ndarray&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>一般来说，图片的存储形式为三维矩阵(宽 <em> 高 </em> 颜色通道数)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 展示图片</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;image&#x27;</span>, img) <span class="comment"># 窗口名字、图像矩阵</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>) <span class="comment"># 等待自动关闭时间（ms级别），使用0代表手动关闭，按任意一个键关闭</span></span><br><span class="line">cv2.destoryAllWindows() <span class="comment"># 关闭窗口</span></span><br></pre></td></tr></table></figure><p>封装一下展示图片的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">show_image</span>(<span class="params">windows_name, image</span>):</span><br><span class="line">    cv2.imshow(windows_name, image)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h4 id="灰度图"><a href="#灰度图" class="headerlink" title="灰度图"></a>灰度图</h4><p> 读取灰度图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image2 = cv2.imread(<span class="string">r&#x27;./img/2.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br></pre></td></tr></table></figure><p> 在图像读取中添加一个第二参数<code>cv2.IMREAD_GRAYSCALE</code>,代表读取该图像的灰度图</p><p>对比代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">image1 = cv2.imread(<span class="string">r&#x27;./img/2.jpg&#x27;</span>)</span><br><span class="line">image2 = cv2.imread(<span class="string">r&#x27;./img/2.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="built_in">print</span>(image1.shape)</span><br><span class="line"><span class="built_in">print</span>(image2.shape)</span><br><span class="line">show_image(<span class="string">&#x27;img1&#x27;</span>, image1)</span><br><span class="line">show_image(<span class="string">&#x27;img2&#x27;</span>, image2)</span><br></pre></td></tr></table></figure><p>这个可以看到，输出的<code>image1.shape=(w,h,3)</code>而<code>image2.shape=(w,h)</code>并且图片也从彩色图片变成黑白图片。</p><h3 id="读取视频"><a href="#读取视频" class="headerlink" title="读取视频"></a>读取视频</h3><blockquote><p>视频实际上就是多张图片按照先后顺序依次展示的样子。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vc = cv2.VideoCapture(<span class="string">r&#x27;./img/1.mp4&#x27;</span>)  <span class="comment"># 读取视频</span></span><br><span class="line"><span class="keyword">if</span> vc.isOpened(): <span class="comment"># 检查是否可以打开</span></span><br><span class="line">    opened, frame = vc.read()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    opened = <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>  对于一个已经打开的视频，每一次读取都会读到一帧的静态图像 <code>opened, frame = vc.read()</code>    (两个参数，一个是不是视频的有效帧、一个是图像帧)</p><p>视频展示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vc = cv2.VideoCapture(<span class="string">r&#x27;./img/1.mp4&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> vc.isOpened():</span><br><span class="line">    opened, frame = vc.read()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    opened = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 视频展示</span></span><br><span class="line"><span class="keyword">while</span> opened:</span><br><span class="line">    ret, frame = vc.read()</span><br><span class="line">    <span class="keyword">if</span> frame <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">       <span class="keyword">break</span></span><br><span class="line">     <span class="keyword">if</span> ret == <span class="literal">True</span>:</span><br><span class="line">       gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) <span class="comment"># 图像转化成灰度图</span></span><br><span class="line">       cv2.imshow(<span class="string">&#x27;result&#x27;</span>,gray)</span><br><span class="line">       <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>: <span class="comment"># 调整视频播放倍速</span></span><br><span class="line">breakvc.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><blockquote><p>从上面可以看到，通常我们说的对于视频的处理，实际上是对于每一帧的图像进行处理。</p></blockquote><h3 id="图像的颜色通道"><a href="#图像的颜色通道" class="headerlink" title="图像的颜色通道"></a>图像的颜色通道</h3><h4 id="切分颜色通道"><a href="#切分颜色通道" class="headerlink" title="切分颜色通道"></a>切分颜色通道</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b, g, r = cv2.split(image) <span class="comment"># (576, 1024, 3)</span></span><br><span class="line"><span class="built_in">print</span>(b.shape) <span class="comment"># (576, 1024)</span></span><br><span class="line"><span class="built_in">print</span>(g.shape) <span class="comment"># (576, 1024)</span></span><br><span class="line"><span class="built_in">print</span>(r.shape) <span class="comment"># (576, 1024)</span></span><br></pre></td></tr></table></figure><h4 id="合并颜色通道"><a href="#合并颜色通道" class="headerlink" title="合并颜色通道"></a>合并颜色通道</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">im = cv2.merge((b, g, r)) <span class="comment"># (576, 1024)</span></span><br><span class="line"><span class="built_in">print</span>(im.shape) <span class="comment"># (576, 1024, 3)</span></span><br></pre></td></tr></table></figure><h4 id="单通道提取"><a href="#单通道提取" class="headerlink" title="单通道提取"></a>单通道提取</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image = cv2.imread(<span class="string">r&#x27;./img/2.jpg&#x27;</span>)</span><br><span class="line">cur_img = image.copy()</span><br><span class="line">cur_img[:, :, <span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">cur_img[:, :, <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">show_image(<span class="string">&#x27;r&#x27;</span>, cur_img)</span><br></pre></td></tr></table></figure><blockquote><p>注意：（0,1,2）=== （b,g,r）这和一般我们的思想rgb不同</p></blockquote><h3 id="边界填充"><a href="#边界填充" class="headerlink" title="边界填充"></a>边界填充</h3><p>  cv2中一共有五种边界填充方式(replicate、reflect、reflect101、wrap、constant)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">top, right, left, bottom = (<span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">replicate = cv2.copyMakeBorder(img, top, bottom, left, right, </span><br><span class="line">                               borderType=cv2.BORDER_REPLICATE)</span><br><span class="line">reflect = cv2.copyMakeBorder(img, top, bottom, left, right, </span><br><span class="line">                             borderType=cv2.BORDER_REFLECT)</span><br><span class="line">reflect101 = cv2.copyMakeBorder(img, top, bottom, left, right, </span><br><span class="line">                                borderType=cv2.BORDER_REFLECT_101)</span><br><span class="line">wrap = cv2.copyMakeBorder(img, top, bottom, left, right, borderType=cv2.BORDER_WRAP)</span><br><span class="line">constant = cv2.copyMakeBorder(img, top, bottom, left, right, </span><br><span class="line">                              borderType=cv2.BORDER_CONSTANT, value=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><ul><li>BORDER_REPLICATE : 复制法，复制最边缘的像素点进行填充</li><li>BORDER_REFLECT：反射法，对感兴趣的图像中的像素在两边进行复制例如：fedcba|abcdefgh|hgfedcb</li><li>BORDER_REFLECT_101：以最边缘的像素为轴做对称如：hgfedcb|abcdefgh|gfedcba</li><li>BORDER_WRAP：外包装法，如：cdefgh|abcdefgh|abcdefg</li><li>BORDER_CONSTANT：常量填充</li></ul><h3 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h3><ul><li>直接在读出的图像矩阵加常数，对数据图像矩阵的所有值都进行加上这个常数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img1 = cv2.imread(<span class="string">r&#x27;./img/2.jpg&#x27;</span>)</span><br><span class="line">img2 = img1 + <span class="number">10</span></span><br></pre></td></tr></table></figure><ul><li>将两图像（规格相同）直接相加（用+号相加），对应数值相加并且若和 <code>s&gt;255</code> 则 <code>s=s%256</code> </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img3 = img1 + img2</span><br><span class="line"><span class="comment"># img1.shape = img2.shape = (576, 1024, 3)</span></span><br></pre></td></tr></table></figure><ul><li>利用<code>cv2.add()</code>对两个图像相加，对应数值相加，若 <code>s&gt;255</code> 则 <code>s=255</code> </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img4 = cv2.add(img1, img2)</span><br></pre></td></tr></table></figure><h4 id="图像融合"><a href="#图像融合" class="headerlink" title="图像融合"></a>图像融合</h4><blockquote><p>注意对于融合的图像大小规格要相同才可以进行融合，对于不同大小的图片进行融合我们需要利用<code>cv2.resize()</code> 来调整图片大小</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img1 = cv2.imread(<span class="string">r&#x27;./img/2.jpg&#x27;</span>) <span class="comment"># (576,1024,3)</span></span><br><span class="line">img2 = cv2.imread(<span class="string">r&#x27;./img/2-1.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line">img2 = cv2.resize(img2, (<span class="number">1024</span>, <span class="number">576</span>)) <span class="comment"># 注意参数的位置</span></span><br></pre></td></tr></table></figure><p><code>cv2.resize()</code> 的用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">show_image(<span class="string">&#x27;0&#x27;</span>, img1)</span><br><span class="line">res = cv2.resize(img1, (<span class="number">0</span>, <span class="number">0</span>), fx=<span class="number">2</span>, fy=<span class="number">1</span>) <span class="comment"># x轴方向伸展2倍</span></span><br><span class="line">show_image(<span class="string">&#x27;1&#x27;</span>, res)</span><br><span class="line">res = cv2.resize(img1, (<span class="number">0</span>, <span class="number">0</span>), fx=<span class="number">1</span>, fy=<span class="number">2</span>) <span class="comment"># y轴方向伸展2倍</span></span><br><span class="line">show_image(<span class="string">&#x27;2&#x27;</span>, res)</span><br><span class="line">res = cv2.resize(img1, (<span class="number">0</span>, <span class="number">0</span>), fx=<span class="number">1.5</span>, fy=<span class="number">1.5</span>) <span class="comment"># x、y轴同时伸展1.5倍</span></span><br><span class="line">show_image(<span class="string">&#x27;3&#x27;</span>, res)</span><br></pre></td></tr></table></figure><p>图像融合可以看成公式 </p><script type="math/tex; mode=display">R=αx_1+βx_2+b，其中x_1，x_2为输入图像,α、β为图像对应的权重，b为图像的亮度偏置值</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = cv2.addWeighted(img1, <span class="number">0.4</span>, img2, <span class="number">0.6</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><code>cv2.addWeighted(x1, α, x2, β, b)</code> 对应的参数</p><h3 id="阈值处理"><a href="#阈值处理" class="headerlink" title="阈值处理"></a>阈值处理</h3><p>二值化处理函数<code>ret,dst=cv2.threshold(src,thresh,maxval,type)</code> 对应的参数解释如下：</p><ul><li><code>src</code>: 输入图，只能输入<strong>单通道</strong>图像，通常是灰度图</li><li><code>dst</code>: 输出图</li><li><code>thresh</code>: 阈值,返回值中的<code>ret</code>就是该值</li><li><code>maxval</code>: 当像素超出阈值（或者是小于阈值，根据type决定）所赋予的值</li><li><code>type</code>: 二值化操作类型，包含5种类型：<ul><li><code>cv2.THRESH_BINARY</code> 超过阈值部分取 <code>maxval</code> （最大值），否则取0</li><li><code>cv2.THRESH_BINARY_INV</code> <code>cv2.THRESH_BINARY</code>的反转</li><li><code>cv2.THRESH_TRUNC</code> 大于阈值的部分设为阈值，否则不变</li><li><code>cv2.THRESH_TOZERO</code> 大于阈值的部分不变，否则设为0</li><li><code>cv2.THRESH_TOZERO_INV</code> <code>cv2.THRESH_TOZERO</code> 的反转</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ret, thresh1 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">ret, thresh2 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV)</span><br><span class="line">ret, thresh3 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TRUNC)</span><br><span class="line">ret, thresh4 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TOZERO)</span><br><span class="line">ret, thresh5 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TOZERO_INV)</span><br><span class="line">images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]</span><br><span class="line">names = [<span class="string">&quot;0&quot;</span>, <span class="string">&quot;THRESH_BINARY&quot;</span>, <span class="string">&quot;THRESH_BINARY_INV&quot;</span>, <span class="string">&quot;THRESH_TRUNC&quot;</span>, <span class="string">&quot;THRESH_TOZERO&quot;</span>, <span class="string">&quot;THRESH_TOZERO_INV&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">3</span>, i + <span class="number">1</span>)</span><br><span class="line">    plt.imshow(images[i], <span class="string">&quot;gray&quot;</span>)</span><br><span class="line">    plt.title(names[i])</span><br><span class="line">    plt.xticks([])</span><br><span class="line">    plt.yticks([])</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>输出的图像对比图</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220917112910109.png" alt="二值化模式对比图"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_String_API</title>
      <link href="/2022/09/12/javaString/"/>
      <url>/2022/09/12/javaString/</url>
      
        <content type="html"><![CDATA[<blockquote><p>字符串反转代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverseTestOne</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s).reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode(T4)</title>
      <link href="/2022/09/09/leetcode04/"/>
      <url>/2022/09/09/leetcode04/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-—-04"><a href="#LeetCode-—-04" class="headerlink" title="LeetCode —- 04"></a>LeetCode —- 04</h1><blockquote><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。算法的时间复杂度应该为 O(log (m+n)) 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length + nums2.length;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> find(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, n / <span class="number">2</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> find(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, n / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>) (left + right) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>) find(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, n / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] num1, <span class="type">int</span> i, <span class="type">int</span>[] num2, <span class="type">int</span> j, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num1.length - i &gt; num2.length - j) &#123;</span><br><span class="line">            <span class="keyword">return</span> find(num2, j, num1, i, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num1.length == i) &#123;</span><br><span class="line">            <span class="keyword">return</span> num2[j + k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> min(num1[i], num2[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx1</span> <span class="operator">=</span> min(num1.length, i + k / <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx2</span> <span class="operator">=</span> j + k - k / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (num1[idx1 - <span class="number">1</span>] &lt; num2[idx2 - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> find(num1, idx1, num2, j, k - (idx1 - i));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> find(num1, i, num2, idx2, k - (idx2 - j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码如上；</p><p>思路主要是利用了二分查找的思想，对于两个数组的总长度 l=l1+l2 奇偶的处理是不同的，这个题目实际上是求连个有序数组的第k大小的数。利用k=l/2(初始值)在每个数组中初始值都有设为i=k/2;j=k-k/2对比大小比较小的一部分明显是不合适的可以直接从数组中删除在更新新的k值完成递归</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL（一）</title>
      <link href="/2022/09/09/OpenGL(1)/"/>
      <url>/2022/09/09/OpenGL(1)/</url>
      
        <content type="html"><![CDATA[<p>本文中使用的代码链接 <a href="https://github.com/Mircela/LearnOpenGL.git">GitHub</a></p><h3 id="导入头文件"><a href="#导入头文件" class="headerlink" title="导入头文件"></a>导入头文件</h3><blockquote><p>当导入头文件的时候出现路径问题是，无法找到头文件路径，我们可以查看配置篇的<strong>注意</strong>部分</p></blockquote><p>对于头文件的引入会有要求，按照一下引入顺序进行引入操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br></pre></td></tr></table></figure></p><blockquote><p>请确认是在包含GLFW的头文件之前包含了GLAD的头文件。GLAD的头文件包含了正确的OpenGL头文件（例如<code>GL/gl.h</code>），所以需要在其它依赖于OpenGL的头文件之前包含GLAD。</p></blockquote><h3 id="初始化GLFW"><a href="#初始化GLFW" class="headerlink" title="初始化GLFW"></a>初始化GLFW</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwInit</span>();</span><br><span class="line"><span class="comment">// 设置主要版本和次要版本</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE,GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"><span class="comment">// glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);  MAC OS 系统要使用改行命令完成兼容操作</span></span><br></pre></td></tr></table></figure><p>​    我们在main函数中调用<code>glfwInit</code>函数来初始化GLFW，然后我们可以使用<code>glfwWindowHint</code>函数来配置GLFW。<code>glfwWindowHint</code>函数的第一个参数代表选项的名称，我们可以从很多以<code>GLFW_</code>开头的枚举值中选择；第二个参数接受一个整型，用来设置这个选项的值。该函数的所有的选项以及对应的值都可以在 <a href="http://www.glfw.org/docs/latest/window.html#window_hints">GLFW’s window handling</a> 这篇文档中找到。</p><h3 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h3><p>​    接下来我们创建一个窗口对象，这个窗口对象存放了所有和窗口相关的数据，而且会被GLFW的其他函数频繁地用到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>,<span class="number">600</span>,<span class="string">&quot;learnOpenGL&quot;</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(window == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;open wrong!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br></pre></td></tr></table></figure><p>​    <code>glfwCreateWindow</code>函数需要窗口的宽和高作为它的前两个参数。第三个参数表示这个窗口的名称（标题），这里我们使用<code>&quot;LearnOpenGL&quot;</code>，当然你也可以使用你喜欢的名称。最后两个参数我们暂时忽略。这个函数将会返回一个<code>GLFWwindow</code>对象，我们会在其它的GLFW操作中使用到。创建完窗口我们就可以通知GLFW将我们窗口的上下文设置为当前线程的主上下文了。</p><h3 id="初始化GLAD"><a href="#初始化GLAD" class="headerlink" title="初始化GLAD"></a>初始化GLAD</h3><p>​    GLAD是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLAD。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    我们给GLAD传入了用来加载系统相关的OpenGL函数指针地址的函数。GLFW给我们的是<code>glfwGetProcAddress</code>，它根据我们编译的系统定义了正确的函数。</p><h3 id="设置视口"><a href="#设置视口" class="headerlink" title="设置视口"></a>设置视口</h3><p>​    在我们开始渲染之前还有一件重要的事情要做，我们必须告诉OpenGL渲染窗口的尺寸大小，即视口(Viewport)，这样OpenGL才只能知道怎样根据窗口大小显示数据和坐标。</p><p>​    我们可以通过调用<code>glViewport</code>函数来设置窗口的<strong>维度</strong>(Dimension)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);</span><br></pre></td></tr></table></figure><p><code>glViewport</code>函数前两个参数控制窗口左下角的位置。第三个和第四个参数控制渲染窗口的宽度和高度（像素）。</p><p>​    我们实际上也可以将视口的维度设置为比GLFW的维度小，这样子之后所有的OpenGL渲染将会在一个更小的窗口中显示，这样子的话我们也可以将一些其它元素显示在OpenGL视口之外。</p><blockquote><p>OpenGL幕后使用<code>glViewport</code>中定义的位置和宽高进行2D坐标的转换，将OpenGL中的位置坐标转换为你的屏幕坐标。例如，OpenGL中的坐标(-0.5, 0.5)有可能（最终）被映射为屏幕中的坐标(200,450)。注意，处理过的OpenGL坐标范围只为-1到1，因此我们事实上将(-1到1)范围内的坐标映射到(0, 800)和(0, 600)。</p></blockquote><p>​    然而，当用户改变窗口的大小的时候，视口也应该被调整。我们可以对窗口注册一个回调函数(Callback Function)，它会在每次窗口大小被调整的时候被调用。这个回调函数的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br></pre></td></tr></table></figure><p>​    这个帧缓冲大小函数需要一个<code>GLFWwindow</code>作为它的第一个参数，以及两个整数表示窗口的新维度。每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    我们还需要注册这个函数，告诉GLFW我们希望每当窗口调整大小的时候调用这个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br></pre></td></tr></table></figure><p>​    当窗口被第一次显示的时候<code>framebuffer_size_callback</code>也会被调用。对于视网膜(Retina)显示屏，<code>width</code>和<code>height</code>都会明显比原输入值更高一点。</p><p>​    我们还可以将我们的函数注册到其它很多的回调函数中。比如说，我们可以创建一个回调函数来处理手柄输入变化，处理错误消息等。我们会在创建窗口之后，渲染循环初始化之前注册这些回调函数。</p><h3 id="渲染循环"><a href="#渲染循环" class="headerlink" title="渲染循环"></a>渲染循环</h3><p> 我们可不希望只绘制一个图像之后我们的应用程序就立即退出并关闭窗口。我们希望程序在我们主动关闭它之前不断绘制图像并能够接受用户输入。因此，我们需要在程序中添加一个while循环，我们可以把它称之为<strong><em>渲染循环(Render Loop)</em></strong>，它能在我们让GLFW退出前一直保持运行。下面几行的代码就实现了一个简单的渲染循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))&#123;</span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>glfwWindowShouldClose</code>函数在我们每次循环的开始前检查一次GLFW是否被要求退出，如果是的话该函数返回<code>true</code>然后渲染循环便结束了，之后为我们就可以关闭应用程序了。</li><li><code>glfwPollEvents</code>函数检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数（可以通过回调方法手动设置）。</li><li><code>glfwSwapBuffers</code>函数会交换颜色缓冲（它是一个储存着GLFW窗口每一个像素颜色值的大缓冲），它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。</li></ul><blockquote><p><strong>双缓冲(Double Buffer)</strong><br>应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。前缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在后缓冲上绘制。当所有的渲染指令执行完毕后，我们交换(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。</p></blockquote><h3 id="最后一件事"><a href="#最后一件事" class="headerlink" title="最后一件事"></a>最后一件事</h3><p>回收资源：我们可以在main函数的最后调用<code>glfwTerminate</code>函数来完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwTerminate</span>();</span><br></pre></td></tr></table></figure><p>我们运行程序，得到结果如下图所示，代表你的代码成功了</p><p><img src="https://mirclea.oss-cn-shenzhen.aliyuncs.com/image-20220919112724199.png" alt="运行结果图"></p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>​    我们同样也希望能够在GLFW中实现一些输入控制，这可以通过使用GLFW的几个输入函数来完成。我们将会使用GLFW的<code>glfwGetKey</code>函数，它需要一个窗口以及一个按键作为输入。这个函数将会返回这个按键是否正在被按下。我们将创建一个<code>processInput</code>函数来让所有的输入代码保持整洁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        <span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这里我们检查用户是否按下了返回键(Esc)（如果没有按下，<code>glfwGetKey</code>将会返回<code>GLFW_RELEASE</code>。如果用户的确按下了返回键，我们将通过<code>glfwSetwindowShouldClose</code>使用把<code>WindowShouldClose</code>属性设置为 <code>true</code>的方法关闭GLFW。下一次while循环的条件检测将会失败，程序将会关闭。</p><p>​    我们接下来在渲染循环的每一个迭代中调用<code>processInput</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">processInput</span>(window); <span class="comment">// 渲染按键信息</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就给我们一个非常简单的方式来检测特定的键是否被按下，并在每一帧做出处理。</p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>​    我们要把所有的渲染(Rendering)操作放到渲染循环中，因为我们想让这些渲染指令在每次渲染循环迭代的时候都能被执行。代码将会是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染循环</span></span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 输入</span></span><br><span class="line">    <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染指令</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查并调用事件，交换缓冲</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    为了测试一切都正常工作，我们使用一个自定义的颜色清空屏幕。在每个新的渲染迭代开始的时候我们总是希望清屏，否则我们仍能看见上一次迭代的渲染结果（这可能是你想要的效果，但通常这不是）。我们可以通过调用<code>glClear</code>函数来清空屏幕的颜色缓冲，它接受一个缓冲位(Buffer Bit)来指定要清空的缓冲，可能的缓冲位有<code>GL_COLOR_BUFFER_BIT</code>，<code>GL_DEPTH_BUFFER_BIT</code>和<code>GL_STENCIL_BUFFER_BIT</code>。由于现在我们只关心颜色值，所以我们只清空颜色缓冲。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br></pre></td></tr></table></figure><p>注意，除了<code>glClear</code>之外，我们还调用了<code>glClearColor</code>来设置清空屏幕所用的颜色。当调用<code>glClear</code>函数，清除颜色缓冲之后，整个颜色缓冲都会被填充为<code>glClearColor</code>里所设置的颜色。在这里，我们将屏幕设置为了类似黑板的深蓝绿色。</p><blockquote><p><code>glClearColor</code>函数是一个<strong>状态设置</strong>函数，而<code>glClear</code>函数则是一个<strong>状态使用</strong>的函数，它使用了当前的状态来获取应该清除为的颜色。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/09/07/hello/"/>
      <url>/2022/09/07/hello/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
